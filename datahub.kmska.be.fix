# Catmandu Fix

# Institution: Royal Museum for Fine Arts Antwerp
# Description: Converts TMS datastructures to LIDO 1.0
# Created: 8/11/2017



### Prepare an intermediate structure

# Retain only those records where DepartmentID equals 1

    select all_match(DepartmentID, '1')

# Copy relevant fields in order to create a dedicated LIDO structure
# Some fields, for example ObjectNumber, ObjectID, DateBegin, DateEnd, Dated and Medium, are obtained from the Objects table in MySQL
# Additional data is obtained from SQLite database files

    # Identifiers

    copy_field(ObjectNumber, or_record.object_number.local)

    copy_field(ObjectID, or_record.object_number.tms)

    copy_field(ObjectNumber, or_record.object_number.datapid)
    lookup_in_store(or_record.object_number.datapid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.datapids.sqlite')
    move_field(or_record.object_number.datapid.dataPid, or_record.object_number.pid.dataPid)
    remove_field(or_record.object_number.datapid)

    copy_field(ObjectNumber, or_record.object_number.workpid)
    lookup_in_store(or_record.object_number.workpid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.workpids.sqlite')
    move_field(or_record.object_number.workpid.workPid, or_record.object_number.pid.workPid)
    remove_field(or_record.object_number.workpid)

    copy_field(ObjectNumber, or_record.object_number.representationpid)
    lookup_in_store(or_record.object_number.representationpid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.representationpids.sqlite')
    move_field(or_record.object_number.representationpid.representationPid, or_record.object_number.pid.representationPid)
    remove_field(or_record.object_number.representationpid)

    # aat

    copy_field(ObjectID, or_record.aat.db)
    lookup_in_store(or_record.aat.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.aat.sqlite')

    # objectWrap

    copy_field(ObjectID, or_record.objectWrap.db)
    lookup_in_store(or_record.objectWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.objects.sqlite')

    # objectNames

    copy_field(ObjectID, or_record.objectNames.db)
    lookup_in_store(or_record.objectNames.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.objectnames.sqlite')

    # classificationWrap

    copy_field(ObjectID, or_record.classificationWrap.db)
    lookup_in_store(or_record.classificationWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.classifications.sqlite')

    # subjectWrap

    copy_field(ObjectID, or_record.subjectWrap.db)
    lookup_in_store(or_record.subjectWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.subjects.sqlite')

    # materialWrap

    copy_field(ObjectID, or_record.materialWrap.db)
    lookup_in_store(or_record.materialWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.materials.sqlite')

    # techniqueWrap

    copy_field(ObjectID, or_record.techniqueWrap.db)
    lookup_in_store(or_record.techniqueWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.techniques.sqlite')

    # title

    copy_field(ObjectNumber, or_record.titleWrap.db)
    lookup_in_store(or_record.titleWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.objtitles.sqlite')

    # inscriptions

    copy_field(Inscribed, or_record.inscriptions)

    # location

    copy_field(ObjectID, or_record.location.db)
    lookup_in_store(or_record.location.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.locations.sqlite')

    # clusters

#    copy_field(ObjectID, or_record.clusters.db)
#    lookup_in_store(or_record.clusters.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.clusters.sqlite')

    # halls

#    copy_field(ObjectID, or_record.halls.db)
#    lookup_in_store(or_record.halls.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.halls.sqlite')

    # textEntries

    copy_field(ObjectID, or_record.textEntries.db)
    lookup_in_store(or_record.textEntries.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.textentries.sqlite')

    # pageNumber

    copy_field(ObjectID, or_record.pageNumber.db)
    lookup_in_store(or_record.pageNumber.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.pagenumbers.sqlite')

    # handling

    copy_field(ObjectID, or_record.handling.db)
    lookup_in_store(or_record.handling.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.handling.sqlite')

    # objectMeasurements

    copy_field(ObjectID, or_record.objectMeasurements.db)
    lookup_in_store(or_record.objectMeasurements.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.dimensions.sqlite')

    # acquisition

    copy_field(ObjectID, or_record.acquisition.db)
    lookup_in_store(or_record.acquisition.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.acquisition.sqlite')

    # production actor (production)

    copy_field(ObjectID, or_record.constituentWrap.db)
    lookup_in_store(or_record.constituentWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.constituents.sqlite')

    # production date (production)

    unless all_equal(DateBegin, '0')
        copy_field(DateBegin, or_record.date.begin)
    end

    unless all_equal(DateEnd, '0')
        copy_field(DateEnd, or_record.date.end)
    end

    copy_field(Dated, or_record.date.display)

    trim(or_record.date.begin)
    trim(or_record.date.end)
    trim(or_record.date.display)

    # period

    copy_field(ObjectID, or_record.periodName)
    lookup_in_store(or_record.periodName, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.periods.sqlite')

    # place (not yet added)

    # eventMaterialsTech

    copy_field(Medium, or_record.eventMaterialsTech.display)

    # provenance

    copy_field(Provenance, or_record.provenance)
    replace_all(or_record.provenance, '\r', '')

    # restoration

    copy_field(CreditLine, or_record.restoration)

    # subjectConcept

    copy_field(Notes, or_record.iconclass)

    # relatedWorksWrap

    copy_field(ObjectID, or_record.relationWrap.db)
    lookup_in_store(or_record.relationWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.relations.sqlite')

    # linkLibrary

    copy_field(UserNumber1, or_record.linkLibrary)

    # linkArchive

    copy_field(ObjectID, or_record.linkArchive.db)
    lookup_in_store(or_record.linkArchive.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.linkarchive.sqlite')

    # recordSource

    copy_field(ObjectID, or_record.department.db)
    lookup_in_store(or_record.department.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.departments.sqlite')

# Remove all fields from Objects, retaining only the ones necessary to create the LIDO structure

    retain(or_record)



### Mapping to lido structure

# Mapping Facets
# ---------------------------------------------------------------------------------------------------------------------------------------------------
# TMS - MySQL                             LIDO                                                VKC                     Invulboek veld
#                                             lido:lidoRecID
#   vdatapids.dataPid                             type: purl                                                              waarde databanknummer
#                                                 type: urn
#   vworkpids.workPid                         lido:objectPublishedID                              Work PURL               waarde objectnummer
#                                             lido:category
#                                                 lido:conceptID
#                                                 lido:term
#                                             lido:objectWorkType
#                                                 lido:conceptID
#   vobjectnames.objectNameID                        pref: preferred                                                      identificatie objectnaam
#                                                 lido:term
#   vobjectnames.objectName                          pref: preferred                              Subtype                 term objectnaam
#                                             lido:classification
#                                                 type: object-category
#                                                    lido:conceptID
#   vclassifications.ClassificationID                     pref: preferred
#                                                         pref: alternate                                                 identificatie
#                                                    lido:term
#   vclassifications.Classification                       pref: preferred                         Type                    term
#                                                         pref: alternate                         Type
#                                             lido:titleSet
#                                                 lido:appellationValue
#   vobjtitles.title                                  lang: en                                                            titel
#   vobjtitles.title                                  lang: nl                                                            titel
#                                                 lido:sourceAppellation
#   vobjtitles.titleid                                lang: en
#   vobjtitles.titleid                                lang: nl
#                                             lido:inscriptions
#   Objects.Inscribed                             lido:inscriptionDescription
#                                             lido:repositorySet
#                                                 lido:repositoryName
#   vdepartments.DepartmentID                         lido:legalBodyID
#   vdepartments.department                           lido:legalBodyName                          Instelling              naam bewaarinstelling
#                                                 lido:workID
#   Objects.ObjectNumber                              type: object-number                         Inventarisnummer        waarde objectnummer
#   vlocations.room                               lido:repositoryLocation
#                                             lido:objectDescriptionSet
#   vtextentries.textEntry                            lido:descriptiveNoteValue                   Beschrijving            korte beschrijving
#                                                 type: page-number
#   vpagenumbers.pageNumber                           lido:descriptiveNoteValue
#                                                 type: handling
#   vhandling.handling                                lido:descriptiveNoteValue
#                                             lido:objectMeasurementsSet
#   vdimensions.display                           lido:displayObjectMeasurements
#                                                 lido:objectMeasurements
#                                                     lido:measurementsSet
#   vdimensions.type                                      lido:measurementType                                            dimensie afmeting
#   vdimensions.unit                                      lido:measurementUnit                    Dimensies               eenheid afmeting
#   vdimensions.dimension                                 lido:measurementValue                   Dimensies               waarde afmeting
#   vdimensions.element                               lido:extentMeasurements                                             onderdeel afmeting
#                                             lido:eventType
#                                                 lido:term
#                                                     acquisition
#                                                         lido:eventActor
#                                                             lido:actorID
#   vacquisition.constituentID                                    type: local
#   vacquisition.name                                         lido:nameActorSet                                           naam verwervingsbron
#                                                         lido:eventDate
#   vacquisition.date                                         lido:displayDate                                            waarde verwervingdatum
#                                                         lido:eventMethod
#   vacquisition.role                                         lido:term                                                   term verwervingsmethode
#                                                         lido:eventDescriptionSet
#                                             lido:eventType
#                                                 lido:term
#                                                     production
#                                                         lido:eventActor
#                                                             lido:actorID
#   vconstituents.ConstituentID                                   type: local
#                                                                 type: purl                                              identificatie vervaardiger
#                                                             lido:nameActorSet
#   vconstituents.DisplayName                                     pref: preferred                 Vervaardiger            naam vervaardiger
#                                                                 pref: alternate
#                                                             lido:vitalDatesActor
#   vconstituents.BeginDateISO                                    lido:earliestDate
#   vconstituents.EndDateISO                                      lido:latestDate
#   vconstituents.Role                                        lido:roleActor                      Vervaardiger            rol vervaardiger
#   vconstituents.Role                                        lido:attributionQualifierActor      Vervaardiger            kwalificatie vervaardiger
#                                                         lido:eventDate
#   Objects.Dated                                             lido:displayDate                    Datering
#                                                             lido:date
#   Objects.DateBegin                                             lido:earliestDate                                       begindatum
#   Objects.DateEnd                                               lido:latestDate                                         einddatum
#                                                         lido:periodName
#   vperiods.term                                             lido:term
#                                                         lido:eventMaterialsTech
#                                                             lido:termMaterialsTech
#                                                                 type: material
#                                                                     lido:conceptID
#   vmaterials.TermID                                                     pref: preferred
#                                                                         pref: alternate                                 identificatie materiaal
#                                                                     lido:term
#   vmaterials.material                                                   pref: preferred         Materiaal               term materiaal
#                                                                         pref: alternate
#                                                                 type: technique
#                                                                     lido:conceptID
#   vtechniques.TermID                                                    pref: preferred
#                                                                     lido:term
#   vtechniques.technique                                                 pref: preferred
#   Objects.Medium                                            lido:displayMaterialsTech
#                                             lido:eventType
#                                                 lido:term
#                                                     provenance
#   Objects.Provenance                                    lido:eventDescriptionSet
#                                             lido:eventType
#                                                 lido:term
#                                                     restoration
#   Objects.CreditLine                                    lido:eventDescriptionSet
#                                             lido:objectRelationWrap
#                                                 lido:subjectWrap
#                                                     lido:subject
#                                                         type: content-motif-general
#                                                             lido:subjectConcept
#                                                                 lido:conceptID
#   vsubjects.TermID                                                  pref: preferred
#                                                                     pref: alternate                                     identificatie hoofdmotief
#                                                                 lido:term
#   vsubjects.subject                                                 pref: preferred             Onderwerp               term hoofdmotief
#                                                                     pref: alternate             Onderwerp
#                                                         no type
#                                                             lido:subjectConcept
#   Objects.Notes                                                 lido:conceptID                                          identificatie afgebeeld concept
#   Objects.Notes                                                 lido:term                                               term afgebeeld concept
#                                                 lido:relatedWorksWrap
#                                                     lido:relatedWorkSet
#   vrelations.numbering                                  sortorder
#                                                             lido:relatedWork
#                                                                 lido:objectID
#   vrelations.relatedObjectNumber                                    type: local
#                                                                     type: oai
#                                                             lido:relatedWorkRelType
#   vrelations.relationshipID1(2)                                 lido:conceptID
#                                                                     type: local
#                                                                     type: URI
#   vrelations.relationship                                       lido:term
#                                                     lido:relatedWorkSet
#   Objects.UserNumber1                                   lido:objectWebResource
#                                                             label: link-library
#                                                     lido:relatedWorkSet
#   vlinkarchive.link                                     lido:objectWebResource
#                                                             label: link-archive
#                                             lido:rightsWorkWrap
#                                                 lido:rightsType
#                                                     lido:conceptID                                                      identificatie rechten werk
#   vconstituents.copyright                           lido:term                                                           term rechten werk
#   vconstituents.copyright                       lido:creditLine
#                                             lido:recordWrap
#                                                 lido:recordID
#   vdatapids.dataPid                                 type: global                                Data PURL               waarde databanknummer
#   Objects.ObjectID                                  type: local                                                         waarde databanknummer
#                                                 lido:recordType
#                                                     lido:conceptID
#                                                     lido:term
#                                                 lido:recordSource
#   vdepartments.DepartmentID                         lido:legalBodyID                                                    identificatie data provider
#   vdepartments.department                           lido:legalBodyName                                                  naam data provider
#                                                     lido:legalBodyWeblink
#                                             lido:resourceWrap
#   vrepresentationpids.representationPid         lido:resourceID
#                                                 lido:resourceRepresentation
#   vrepresentationpids.representationPid             lido:linkResource



### LIDO lidoRecID

    # ID
    #
    # The ID in Solr is based on the data_pid. The data_pid is converted to a string
    # which can be safely used as an identifier in Project Blacklight. The format of
    # the ID field looks like this:
    #
    #   oai:datahub.kmska.be:<domain>:<identifier>
    #   ex. oai:datahub.kmska.be:kmksa.be:254
    #   ex. oai:datahub.kmska.be:collectievlaamsegemeenschap.be:837
    #
    # Note: the .tld is stripped from the domainname because the . (dot) breaks the
    # route matching algoritm.

    # Create datahub record ID

    copy_field('or_record.object_number.pid.dataPid', 'or_record.object_number.pid.oaiPid')
    parse_text('or_record.object_number.pid.oaiPid', '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
    join_field('or_record.object_number.pid.oaiPid', ':')
    prepend('or_record.object_number.pid.oaiPid', 'oai:datahub.kmska.be:')

    # Add datapid from TMS as LIDO lidoRecID (type:purl)

    lido_baseid(
        lidoRecID,
        or_record.object_number.pid.dataPid,
        -type: purl,
        -source: 'Koninklijk Museum voor Schone Kunsten Antwerpen',
        -label: dataPID,
        -pref: alternate
    )

    # Add the created datahub record ID as LIDO lidoRecID (type:urn)

    lido_baseid(
        lidoRecID,
        or_record.object_number.pid.oaiPid,
        -type: urn,
        -source: 'Koninklijk Museum voor Schone Kunsten Antwerpen',
        -label: dataPID,
        -pref: preferred
    )



### LIDO objectPublishedID

    # Add workpid from TMS as LIDO objectPublishedID

    lido_baseid(
        objectPublishedID,
        or_record.object_number.pid.workPid,
        -source: 'Koninklijk Museum voor Schone Kunsten Antwerpen',
        -type: purl,
        -label: workPID
    )



### LIDO category

    # Create CIDOCCategoryTerm and CIDOCCategoryURI

    add_field(or_record.CIDOCCategoryTerm, 'Man-Made Object')
    add_field(or_record.CIDOCCategoryURI, 'http://www.cidoc-crm.org/Entity/e22-man-made-object/version-6.1')

    # Add the created CIDOCCategoryTerm to LIDO category as LIDO term along with the CIDOCCategoryURI as LIDO conceptID

    lido_term(
        category,
        or_record.CIDOCCategoryTerm,
        -conceptid: or_record.CIDOCCategoryURI,
        -type: purl,
        -source: cidoc-crm
    )



### LIDO descriptiveMetadata

## LIDO objectClassificationWrap

# LIDO objectWorkType

    # We'll have multiple object names: the corresponding value from AAT (source:AAT) and the value from TMS (source:TMS)

    # Loop over the different object names from TMS

    do list(path:or_record.objectNames.db.objectnames, var:n)

        # Use ObjectNameTypeID 0 (not entered) or 2 (object name by form)

        if all_match(n.objectNameTypeID, '^[02]$')

            # Add each object name from TMS to LIDO objectWorkType as LIDO term (pref:preferred) along with the ObjectNameID from TMS as LIDO conceptID (pref:preferred)

            lido_term(
                descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$append,
                n.objectName,
                -conceptid: n.objectNameID,
                -type: local,
                -source: TMS,
                -pref: preferred,
                -lang: nl
            )

            add_field(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last.type, 'form')

        end

    end

    set_field(or_record.objectName_aat_exists, '')

    # Loop over the different object names from AAT

    do list(path:or_record.aat.db.aat, var:a)

        # Use path starting with 'TGO.AAI' or 'AAT.V'

        if all_match(a.path, '^TGO\.AAI|AAT\.V.*$')

            set_field(or_record.objectName_aat_exists, 'true')

            lido_term(
                descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$append,
                a.term,
                -pref: preferred,
                -lang: nl
            )

            # Retrieve the corresponding term and URI from the AAT vocabulary

            copy_field(a.term, a.objectName_aat)
            lookup_in_store(a.objectName_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

            # Add the corresponding term from the AAT vocabulary (if present) to LIDO objectWorkType as LIDO term (pref:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (pref:alternate)

            if all_match(a.objectName_aat.aatterm, '.*\S.*')

                if all_match(a.objectName_aat.aaturi, '.*\S.*')

                    lido_term(
                        descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                        a.objectName_aat.aatterm,
                        -conceptid: a.objectName_aat.aaturi,
                        -type: purl,
                        -source: AAT,
                        -pref: alternate,
                        -lang: nl
                    )

                else

                    lido_term(
                        descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                        a.objectName_aat.aatterm,
                        -pref: alternate,
                        -lang: nl
                    )

                end

            end

            unless all_match(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last.conceptID.source, '.*\S.*')

                add_field(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last.conceptID._, '')
                add_field(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last.conceptID.type, 'purl')
                add_field(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last.conceptID.source, 'AAT')

            end

        end

    end

    # If there is no object name from AAT, try using object terms

    unless all_match(or_record.objectName_aat_exists, 'true')

        # We'll have multiple object terms: the corresponding value from the AAT vocabulary (pref:alternate) and the value from TMS (pref:preferred)

        # Loop over the different object terms from TMS

        do list(path:or_record.objectWrap.db.objects, var:o)

            # Add each object term from TMS to LIDO objectWorkType as LIDO term (pref:preferred) along with the termID from TMS as LIDO conceptID (pref:preferred)

            lido_term(
                descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$append,
                o.object,
                -conceptid: o.TermID,
                -type: local,
                -source: TMS,
                -pref: preferred,
                -lang: nl
            )

            # Retrieve the corresponding term and URI from the AAT vocabulary

            copy_field(o.object, o.object_aat)
            lookup_in_store(o.object_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

            # Add the corresponding term from the AAT vocabulary (if present) to LIDO objectWorkType as LIDO term (pref:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (pref:alternate)

            if all_match(o.object_aat.aatterm, '.*\S.*')

                if all_match(o.object_aat.aaturi, '.*\S.*')

                    lido_term(
                        descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                        o.object_aat.aatterm,
                        -conceptid: o.object_aat.aaturi,
                        -type: purl,
                        -source: AAT,
                        -pref: alternate,
                        -lang: nl
                    )

                else

                    lido_term(
                        descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                        o.object_aat.aatterm,
                        -pref: alternate,
                        -lang: nl
                    )

                end

            end

        end

    end

# LIDO classification [type="object-category"]

    # We'll have multiple terms for the type "object-category": the corresponding value from the AAT vocabulary (pref:alternate) and the value from TMS (pref:preferred)

    # Loop over the different classification terms from TMS

    do list(path:or_record.classificationWrap.db.classifications, var:c)

        # Add each classification term from TMS to LIDO classification as LIDO term (pref:preferred) along with the classificationID from TMS as LIDO conceptID (pref:preferred)

        lido_term(
            descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$append,
            c.Classification,
            -conceptid: c.ClassificationID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        # Add type of LIDO classification

        add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.type, "object-category")

        # Retrieve the corresponding term and URI from the AAT vocabulary

        copy_field(c.Classification, c.classification_aat)
        lookup_in_store(c.classification_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO classification as LIDO term (pref:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (pref:alternate)

        if all_match(c.classification_aat.aatterm, '.*\S.*')

            if all_match(c.classification_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last,
                    c.classification_aat.aatterm,
                    -conceptid: c.classification_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last,
                    c.classification_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )                

            end

            # Add type of LIDO classification

            add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.type, "object-category")

        end

    end


## LIDO objectIdentificationWrap

# LIDO titleSet

    # Loop over the different titles from TMS

    do list(path:or_record.titleWrap.db.objtitles, var:t)

        # Use TitleTypeID 1 (titles)

        if all_match(t.titletypeid, '1')

            # Remove unnecessary whitespaces

            trim(t.title)
            trim(t.titleid)

            # Add each title from TMS to LIDO titleSet as LIDO appellationValue along with the titleID from TMS as LIDO sourceAppellation

            copy_field(t.title, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$append._)
            set_field(descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$last.pref, 'preferred')
            copy_field(t.language, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$last.lang)
            copy_field(t.titleid, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.sourceAppellation.$append._)
            copy_field(t.language, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.sourceAppellation.$last.lang)

        end

    end

    # If there is no title, try using TitleTypeID 2 (series titles)

    unless all_match(descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.0._, '.*\S.*')

        # Loop over the different titles from TMS

        do list(path:or_record.titleWrap.db.objtitles, var:t)

            if all_match(t.titletypeid, '2')

                # Remove unnecessary whitespaces

                trim(t.title)
                trim(t.titleid)

                # Add each series title from TMS to LIDO titleSet with type 'series-title' as LIDO appellationValue along with the titleID from TMS as LIDO sourceAppellation

                set_field(descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.type, 'series-title')
                copy_field(t.title, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$append._)
                set_field(descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$last.pref, 'preferred')
                copy_field(t.language, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$last.lang)
                copy_field(t.titleid, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.sourceAppellation.$append._)
                copy_field(t.language, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.sourceAppellation.$last.lang)

            end

        end

    end

# LIDO inscriptions

    # Split separate inscriptions

    split_field(or_record.inscriptions, '(\r\n|\r|\n)')

    # Loop over the separate inscriptions

    do list(path:or_record.inscriptions, var:i)

        if all_match('i', '.*\S.*')

            # Add a new, empty LIDO inscriptions field

            add_field(descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$append)

            copy_field(i, or_record.inscription)

            if all_match(or_record.inscription, '.*:.*')

                # Split the inscriptions on the colon

                split_field(or_record.inscription, ':')

                set_field(or_record.inscriptionDescription)

                # Loop over the different parts of the inscriptions

                do list(path:or_record.inscription, var:in)

                    # Remove unnecessary whitespaces and parentheses

                    if all_match(in, '.*\S.*')

                        trim(in)

                        if all_match(in, '^\(.*\)$')

                            replace_all(in,'^\((.*)',$1)
                            replace_all(in,'(.*)\)$',$1)

                        end

                        if all_match (descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$last.type, 'position')

                            # Add each inscription content from TMS (if present) to LIDO inscriptions as LIDO inscriptionTranscription

                            copy_field('in', descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionTranscription._)

                            paste(or_record.inscriptionDescription, or_record.inscriptionDescription, in, join_char:': ')

                        else

                            # Add each inscription position from TMS (if present) to LIDO inscriptions as LIDO inscriptionDescription (type:position)

                            copy_field('in', descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$append.descriptiveNoteValue._)
                            add_field(descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$last.type, "position")
                            add_field(descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$last.descriptiveNoteValue.lang, "nl")

                            copy_field('in', or_record.inscriptionDescription)

                        end

                    end

                end

                # Add each entire inscription description from TMS (if present) to LIDO inscriptions as LIDO inscriptionDescription

                if all_match('or_record.inscriptionDescription', '.*\S.*')

                    copy_field('or_record.inscriptionDescription', descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$append.descriptiveNoteValue._)
                    add_field(descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$last.descriptiveNoteValue.lang, "nl")

                end

            else

                # Remove unnecessary whitespaces and parentheses

                trim(or_record.inscription)

                if all_match(or_record.inscription, '^\(.*\)$')

                    replace_all(or_record.inscription,'^\((.*)',$1)
                    replace_all(or_record.inscription,'(.*)\)$',$1)

                end

                # Add each entire inscription description from TMS (if present) to LIDO inscriptions as LIDO inscriptionDescription

                copy_field('or_record.inscription', descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$append.descriptiveNoteValue._)
                add_field(descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$last.descriptiveNoteValue.lang, "nl")

            end

        end

    end

# LIDO repositoryName

    # Add department ID from TMS to LIDO repositoryName as LIDO legalBodyID

    lido_baseid(
        descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$append.repositoryName.legalBodyID,
        or_record.department.db.DepartmentID,
        -type: local,
        -source: TMS
    )

    # Add department from TMS to LIDO repositoryName as LIDO legalBodyName

    lido_basenameset(
        descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryName.legalBodyName,
        or_record.department.db.department
    )

# LIDO workID

    # Add object number from TMS as LIDO workID

    lido_baseid(
        descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.workID,
        or_record.object_number.local,
        -type: object-number
    )

# LIDO repositoryLocation

    # Add location from TMS (if present) to LIDO repositoryLocation as LIDO namePlaceSet

    if all_match(or_record.location.db.room, '.*\S.*')

        # Add new LIDO repositorySet with type "room"

#        add_field(descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$append.type, "room")

        # Add a new, empty LIDO repositorySet field

        add_field(descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$append)

        # Add location to last created LIDO repositorySet

        lido_basenameset(
            descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryLocation.namePlaceSet,
            or_record.location.db.room,
            -value_lang: nl
        )

    end

    # Loop over the different clusters from TMS

#    do list(path:or_record.clusters.db.clusters, var:c)

        # Add each cluster from TMS (if present) to LIDO repositoryLocation as LIDO namePlaceSet

#        if all_match(c.cluster, '.*\S.*')

            # Add new LIDO repositorySet with type "cluster"

#            add_field(descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$append.type, "cluster")

            # Add cluster to last created LIDO repositorySet

#            lido_basenameset(
#                descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryLocation.namePlaceSet,
#                c.cluster
#            )

#        end

#    end

    # Loop over the different halls from TMS

#    do list(path:or_record.halls.db.halls, var:h)

        # Add each hall from TMS (if present) to LIDO repositoryLocation as LIDO namePlaceSet

#        if all_match(h.hall, '.*\S.*')

            # Add new LIDO repositorySet with type "hall"

#            add_field(descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$append.type, "hall")

            # Add hall to last created LIDO repositorySet

#            lido_basenameset(
#                descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryLocation.namePlaceSet,
#                h.hall
#            )

#        end

#    end

# LIDO objectDescriptionSet

    # Loop over the different text entries from TMS

    do list(path:or_record.textEntries.db.textentries, var:t)

        # Add each text entry from TMS (if present) to LIDO objectDescriptionSet as LIDO descriptiveNoteValue

        if all_match(t.textEntry, '.*\S.*')

            # Add a new, empty LIDO objectDescriptionSet field

            add_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$append)

            # Remove unnecessary whitespaces

            trim(t.textEntry)

            # Add the Dutch text entry to last created LIDO objectDescriptionSet

            if all_match(t.languageid, 2)

                copy_field(t.textEntry, descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue._)

                set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue.lang, 'nl')

            end

            # Add the English text entry to last created LIDO objectDescriptionSet

            if all_match(t.languageid, 1)

                copy_field(t.textEntry, descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue._)

                set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue.lang, 'en')

            end

            # Add the text type as type for LIDO objectDescriptionSet

            if all_match(t.textTypeID, '107')

                set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.type, 'note')

            end

            if all_match(t.textTypeID, '110')

                set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.type, 'literature')

            end

            if all_match(t.textTypeID, '113')

                set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.type, 'technical-notes')

            end

            if all_match(t.textTypeID, '117')

                set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.type, 'highlights')

            end

        end

    end

    # Add page number from TMS (if present) to LIDO objectDescriptionSet as LIDO descriptiveNoteValue

    if all_match('or_record.pageNumber.db.pageNumber', '.*\S.*')

        lido_descriptivenote(
            descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet,
            or_record.pageNumber.db.pageNumber
        )

        # Add type 'page-number' for LIDO objectDescriptionSet

        set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.type, 'page-number')

    end

    # Loop over the different handling advices from TMS

    do list(path:or_record.handling.db.handling, var:h)

        # Add each handling advice from TMS (if present) to LIDO objectDescriptionSet as LIDO descriptiveNoteValue

        if all_match(h.textEntry, '.*\S.*')

            # Add a new, empty LIDO objectDescriptionSet field

            add_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$append)

            # Remove unnecessary whitespaces

            trim(h.textEntry)

            # Add the handling advice and language of it to last created LIDO objectDescriptionSet

            copy_field(h.textEntry, descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue._)

            copy_field(h.language, descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue.lang)

            # Add type 'handling' for LIDO objectDescriptionSet

            set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.type, 'handling')

        end

    end

# LIDO objectMeasurementsSet

    # Loop over the different dimensions from TMS

    do list(path:or_record.objectMeasurements.db.dimensions, var:d)

        # Add a new, empty LIDO objectMeasurementsSet field

        add_field(descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$append)

        ## Create the LIDO fields

        # Add display of each dimension from TMS (if present) as LIDO displayObjectMeasurements

        if all_match(d.display, '.*\S.*')

            copy_field(d.display, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.displayObjectMeasurements._)

        end

        # Add type of each dimension from TMS (if present) as LIDO measurementType

        if all_match(d.type, '.*\S.*')

            copy_field(d.type, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementType._)

        end

        # Add unit of each dimension from TMS (if present) as LIDO measurementUnit

        if all_match(d.unit, '.*\S.*')

            copy_field(d.unit, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementUnit._)

        end

        # Add value of each dimension from TMS (if present) as LIDO measurementValue

        if all_match(d.dimension, '.*\S.*')

            copy_field(d.dimension, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementValue._)

        end

        # Add element of each dimension from TMS (if present) as LIDO extentMeasurements

        if all_match(d.element, '.*\S.*')

            copy_field(d.element, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.extentMeasurements._)

        end

    end


## LIDO eventWrap

# LIDO eventType [eventType/term="acquisition"]

    # Create event_type

    add_field(or_record.event_type, "acquisition")

    # Loop over the acquisitions from TMS

    do list(path:or_record.acquisition.db.acquisition, var:a)

        set_field(or_record.acquisition_actor, '')
        set_field(or_record.acquisition_date, '')
        set_field(or_record.acquisition_method, '')

        # Add a new, empty LIDO eventSet field (if acquisition is present) and add the created event type to LIDO eventType

        if all_match(a.name, '.*\S.*')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
                or_record.event_type
            )

        else

            if all_match(a.date, '.*\S.*')

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
                    or_record.event_type
                )

            else

                if all_match(a.role, '.*\S.*')

                    lido_term(
                        descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
                        or_record.event_type
                    )

                end

            end

        end

# LIDO eventActor [eventType/term="acquisition"]

        # Add the display name of each actor from TMS (if present) to LIDO eventActor as LIDO appellationValue along with the constituentID from TMS as LIDO actorID (source:TMS)

        if all_match(a.name, '.*\S.*')

            copy_field(a.name, or_record.acquisition_actor)

            lido_actor(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append,
                a.constituentID,
                a.name,
                -name_lang: nl,
                -id_source: TMS,
                -id_type: local
            )

        end

# LIDO displayDate [eventType/term="acquisition"]

        # Add each display date from TMS (if present) to LIDO eventDate as LIDO displayDate

        if all_match(a.date, '.*\S.*')

            copy_field(a.date, or_record.acquisition_date)

            lido_basevalue(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.displayDate,
                a.date,
                -lang: nl
            )

        end

# LIDO eventMethod [eventType/term="acquisition"]

        # Add each role from TMS (if present) to LIDO eventMethod as LIDO term

        if all_match(a.role, '.*\S.*')

            copy_field(a.role, or_record.acquisition_method)

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMethod.$append,
                a.role,
                -lang: nl
            )

        end

# LIDO eventDescriptionSet [eventType/term="acquisition"]

        # Create the entire acquisition description from the role, name and date from TMS

        set_field(or_record.acquisition_description, '')

        if all_match(or_record.acquisition_method, '.*\S.*')

            copy_field(or_record.acquisition_method, or_record.acquisition_description)

            if all_match(or_record.acquisition_actor, '.*\S.*')

                paste(or_record.acquisition_description, or_record.acquisition_description, or_record.acquisition_actor, join_char:': ')

            end

            if all_match(or_record.acquisition_date, '.*\S.*')

                paste(or_record.acquisition_description, or_record.acquisition_description, or_record.acquisition_date, join_char:', ')

            end

        else

            if all_match(or_record.acquisition_actor, '.*\S.*')

                copy_field(or_record.acquisition_actor, or_record.acquisition_description)

                if all_match(or_record.acquisition_date, '.*\S.*')

                    paste(or_record.acquisition_description, or_record.acquisition_description, or_record.acquisition_date, join_char:', ')

                end

            end

        end

        # Add the created entire acquisition description (if present) to LIDO eventDescriptionSet as LIDO descriptiveNoteValue

        if all_match(or_record.acquisition_description, '.*\S.*')

            lido_descriptivenote(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDescriptionSet,
                or_record.acquisition_description,
                -lang: nl
            )

        end

    end

# LIDO eventType [eventType/term="production"]

    # Create event_type

    add_field(or_record.event_type, "production")

    # Add the created event type to LIDO eventType
    
    lido_term(
        descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
        or_record.event_type
    )

# LIDO eventActor [eventType/term="production"]

    # We'll have multiple appellationValues and actorIDs for the same actor: the corresponding values from the creators vocabulary and the values from TMS

    # Determine which roles from TMS should be added as qualifier

    set_array(qualifiers, "atelier van", "kopie naar", "navolger van", "omgeving van", "school van", "toegeschreven aan", "x")

    # Loop over the different constituents from TMS

    do list(path:or_record.constituentWrap.db.constituents, var:c)

        # Remove unnecessary whitespaces

        trim(c.BeginDateISO)
        trim(c.EndDateISO)

        # Add the display name of each constituent from TMS to LIDO eventActor as LIDO appellationValue (pref:preferred)
        # along with the constituentID from TMS as LIDO actorID (source:TMS),
        # the BeginDateISO from TMS as LIDO earliestDate,
        # the EndDateISO from TMS as LIDO latestDate and,
        # if determined before as qualifier, add the Role from TMS as LIDO attributionQualifierActor
        # else, add the Role from TMS as LIDO roleActor

        unless all_match(c.Role, 'vroegere toeschrijving')

            if in(c.Role, qualifiers)
                lido_actor(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append,
                    c.ConstituentID,
                    c.DisplayName,
                    -id_source: TMS,
                    -id_type: local,
                    -birthdate: c.BeginDateISO,
                    -deathdate: c.EndDateISO,
                    -qualifier: c.Role,
                    -name_pref: preferred
                )
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.attributionQualifierActor.$last.lang, "nl")

            else
                lido_actor(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append,
                    c.ConstituentID,
                    c.DisplayName,
                    -id_source: TMS,
                    -id_type: local,
                    -birthdate: c.BeginDateISO,
                    -deathdate: c.EndDateISO,
                    -role: c.Role,
                    -name_pref: preferred
                )
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.roleActor.$last.term.$last.lang, "nl")
            end

        end

        # Retrieve the corresponding values from the creators vocabulary

        unless all_match(c.Role, 'vroegere toeschrijving')
            copy_field(c.DisplayName, c.creator.pid)
            downcase(c.creator.pid)
            lookup_in_store(c.creator.pid, DBI, data_source: "dbi:SQLite:/tmp/import.CREATORS_UTF8.sqlite")
        end

        # Add the corresponding display name from the creators vocabulary (if present) to LIDO eventActor as LIDO appellationValue (pref:alternate)

        if all_match(c.creator.pid._id, '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.nameActorSet.$last,
                c.creator.pid.display_name,
                -value_pref: alternate
            )

        end

        # Add the corresponding VIAF URI from the creators vocabulary (if present) to LIDO eventActor as LIDO actorID (source:VIAF)

        if all_match(c.creator.pid.viaf_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.viaf_uri,
                -source: VIAF,
                -type: purl
            )

        end

        # Add the corresponding RKD URI from the creators vocabulary (if present) to LIDO eventActor as LIDO actorID (source:RKD)

        if all_match(c.creator.pid.rkd_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.rkd_uri,
                -source: RKD,
                -type: purl
            )

        end

        # Add the corresponding Wikidata URI from the creators vocabulary (if present) to LIDO eventActor as LIDO actorID (source:Wikidata)

        if all_match(c.creator.pid.wikidata_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.wikidata_uri,
                -source: Wikidata,
                -type: purl
            )

        end

    end

    # Remove the created field qualifiers

    remove_field(qualifiers)

# LIDO displayDate [eventType/term="production"]

    # Add display date from TMS (if present) as LIDO displayDate

    if all_match(or_record.date.display, '.*\S.*')

        # Remove unnecessary parentheses

        if all_match(or_record.date.display, '^\(.*\)$')

            replace_all(or_record.date.display,'^\((.*)',$1)
            replace_all(or_record.date.display,'(.*)\)$',$1)

        end

        lido_basevalue(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.displayDate,
            or_record.date.display
        )

    end

# LIDO date [eventType/term="production"]

    # Add begin end end date from TMS (if present) as respectively LIDO earliestDate and LIDO latestDate

    if all_match(or_record.date.begin, '.*\S.*')

        if all_match(or_record.date.end, '.*\S.*')

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -earliest_date: or_record.date.begin,
                -latest_date: or_record.date.end
            )

        else

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -earliest_date: or_record.date.begin
            )

        end

    else

        if all_match(or_record.date.end, '.*\S.*')

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -latest_date: or_record.date.end
            )

        end

    end

# LIDO periodName [eventType/term="production"]

    # Add period from TMS as LIDO periodName

    lido_term(
        descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$append,
        or_record.periodName.term,
        -lang: nl
    )

    # Loop over the different styles and periods from AAT

    do list(path:or_record.aat.db.aat, var:a)

        # Use path starting with 'TGO.AAE'

        if all_match(a.path, '^TGO\.AAE.*$')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$append,
                a.term,
                -pref: preferred,
                -lang: nl
            )

            # Retrieve the corresponding term and URI from the AAT vocabulary

            copy_field(a.term, a.period_aat)
            lookup_in_store(a.period_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

            # Add the corresponding term from the AAT vocabulary (if present) to LIDO periodName as LIDO term (pref:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (pref:alternate)

            if all_match(a.period_aat.aatterm, '.*\S.*')

                if all_match(a.period_aat.aaturi, '.*\S.*')

                    lido_term(
                        descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last,
                        a.period_aat.aatterm,
                        -conceptid: a.period_aat.aaturi,
                        -type: purl,
                        -source: AAT,
                        -pref: alternate,
                        -lang: nl
                    )

                else

                    lido_term(
                        descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last,
                        a.period_aat.aatterm,
                        -pref: alternate,
                        -lang: nl
                    )

                end

            end

            unless all_match(descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last.conceptID.source, '.*\S.*')

                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last.conceptID._, '')
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last.conceptID.type, 'purl')
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last.conceptID.source, 'AAT')

            end

        end

    end

# LIDO namePlaceSet [eventType/term="production"]

    # Not yet added

# LIDO termMaterialsTech [eventType/term="production"]

    set_field(or_record.material_aat_exists, '')

    # Loop over the different materials from AAT

    do list(path:or_record.aat.db.aat, var:a)

        # Use path starting with 'TGO.AAH' or 'AAT.M'

        if all_match(a.path, '^TGO\.AAH|AAT\.M.*$')

            set_field(or_record.material_aat_exists, 'true')

            add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$append.type, "material")

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                a.term,
                -pref: preferred,
                -lang: nl
            )

            # Retrieve the corresponding term and URI from the AAT vocabulary

            copy_field(a.term, a.material_aat)
            lookup_in_store(a.material_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

            # Add the corresponding term from the AAT vocabulary (if present) to LIDO termMaterialsTech as LIDO term (pref:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (pref:alternate)

            if all_match(a.material_aat.aatterm, '.*\S.*')

                if all_match(a.material_aat.aaturi, '.*\S.*')

                    lido_term(
                        descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                        a.material_aat.aatterm,
                        -conceptid: a.material_aat.aaturi,
                        -type: purl,
                        -source: AAT,
                        -pref: alternate,
                        -lang: nl
                    )

                else

                    lido_term(
                        descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                        a.material_aat.aatterm,
                        -pref: alternate,
                        -lang: nl
                    )

                end

            end

            unless all_match(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last.conceptID.source, '.*\S.*')

                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last.conceptID._, '')
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last.conceptID.type, 'purl')
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last.conceptID.source, 'AAT')

            end

        end

    end

    # If there is no material from AAT, try using material terms

    unless all_match(or_record.material_aat_exists, 'true')

        # We'll have multiple terms: the corresponding value from the AAT vocabulary (pref:alternate) and the value from TMS (pref:preferred)

        # Loop over the different material terms from TMS

        do list(path:or_record.materialWrap.db.materials, var:m)

            add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$append.type, "material")

            # Add each material term from TMS to LIDO termMaterialsTech as LIDO term (pref:preferred) along with the termID from TMS as LIDO conceptID (pref:preferred)

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                m.material,
                -conceptid: m.TermID,
                -type: local,
                -source: TMS,
                -pref: preferred,
                -lang: nl
            )

            # Retrieve the corresponding term and URI from the AAT vocabulary

            copy_field(m.material, m.material_aat)
            downcase(m.material_aat)
            lookup_in_store(m.material_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

            # Add the corresponding term from the AAT vocabulary (if present) to LIDO termMaterialsTech as LIDO term (pref:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (pref:alternate)

            if all_match(m.material_aat.aatterm, '.*\S.*')

                if all_match(m.material_aat.aaturi, '.*\S.*')

                    lido_term(
                        descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                        m.material_aat.aatterm,
                        -conceptid: m.material_aat.aaturi,
                        -type: purl,
                        -source: AAT,
                        -pref: alternate,
                        -lang: nl
                    )

                else

                    lido_term(
                        descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                        m.material_aat.aatterm,
                        -pref: alternate,
                        -lang: nl
                    )

                end

            end

        end

    end

    # Loop over the different technique terms from TMS

    do list(path:or_record.techniqueWrap.db.techniques, var:t)

        add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$append.type, "technique")

        # Add each technique term from TMS to LIDO termMaterialsTech as LIDO term (pref:preferred) along with the termID from TMS as LIDO conceptID (pref:preferred)

        lido_term(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
            t.technique,
            -conceptid: t.TermID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        # Retrieve the corresponding term and URI from the AAT vocabulary

        copy_field(t.technique, t.technique_aat)
        downcase(t.technique_aat)
        lookup_in_store(t.technique_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO termMaterialsTech as LIDO term (pref:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (pref:alternate)

        if all_match(t.technique_aat.aatterm, '.*\S.*')

            if all_match(t.technique_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    t.technique_aat.aatterm,
                    -conceptid: t.technique_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    t.technique_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

# LIDO displayMaterialsTech [eventType/term="production"]

    # Add medium from TMS as LIDO displayMaterialsTech

    if all_match(or_record.eventMaterialsTech.display, '.*\S.*')

        lido_basevalue(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.displayMaterialsTech,
            or_record.eventMaterialsTech.display
        )

    end

# LIDO eventType [eventType/term="provenance"]

    # Create event_type

    add_field(or_record.event_type, "provenance")

    # Add a new, empty LIDO eventSet field (if provenance is present) and add the created event type to LIDO eventType

    if all_match(or_record.provenance, '.*\S.*')

        lido_term(
            descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
            or_record.event_type
        )

    end

# LIDO eventDescriptionSet [eventType/term="provenance"]

    # Add provenance description from TMS (if present) to LIDO eventDescriptionSet as LIDO descriptiveNoteValue

    if all_match('or_record.provenance', '.*\S.*')

        # Remove unnecessary whitespaces

        trim(or_record.provenance)

        lido_descriptivenote(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventDescriptionSet,
            or_record.provenance,
            -lang: nl
        )

    end

# LIDO eventType [eventType/term="restoration"]

    # Create event_type

    add_field(or_record.event_type, "restoration")

    # Add a new, empty LIDO eventSet field (if restoration is present) and add the created event type to LIDO eventType

    if all_match(or_record.restoration, '.*\S.*')

        lido_term(
            descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
            or_record.event_type
        )

    end

# LIDO eventDescriptionSet [eventType/term="restoration"]

    # Add restoration description from TMS (if present) to LIDO eventDescriptionSet as LIDO descriptiveNoteValue

    if all_match('or_record.restoration', '.*\S.*')

        # Remove unnecessary whitespaces

        trim(or_record.restoration)

        lido_descriptivenote(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventDescriptionSet,
            or_record.restoration,
            -lang: nl
        )

    end


## LIDO objectRelationWrap

# LIDO subjectConcept

    # AAT

    # Loop over the different associated concepts, agents and activities from AAT

    do list(path:or_record.aat.db.aat, var:a)

        # Use path starting with 'TGO.AAC', 'TGO.AAF' or 'TGO.AAG'

        if all_match(a.path, '^TGO\.AAC|TGO\.AAF|TGO\.AAG.*$')

            lido_term(
                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.subjectConcept.$append,
                a.term,
                -pref: preferred,
                -lang: nl
            )

            # Retrieve the corresponding term and URI from the AAT vocabulary

            copy_field(a.term, a.subject_aat)
            lookup_in_store(a.subject_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

            # Add the corresponding term from the AAT vocabulary (if present) to LIDO subjectConcept as LIDO term (pref:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (pref:alternate)

            if all_match(a.subject_aat.aatterm, '.*\S.*')

                if all_match(a.subject_aat.aaturi, '.*\S.*')

                    lido_term(
                        descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                        a.subject_aat.aatterm,
                        -conceptid: a.subject_aat.aaturi,
                        -type: purl,
                        -source: AAT,
                        -pref: alternate,
                        -lang: nl
                    )

                else

                    lido_term(
                        descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                        a.subject_aat.aatterm,
                        -pref: alternate,
                        -lang: nl
                    )

                end

            end

            unless all_match(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.source, '.*\S.*')

                add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID._, '')
                add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.type, 'purl')
                add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.source, 'AAT')

            end

            if all_match(a.path, '^TGO\.AAC.*$')

                add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.type, 'associated-concept')

            end

            if all_match(a.path, '^TGO\.AAF.*$')

                add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.type, 'agent')

            end

            if all_match(a.path, '^TGO\.AAG.*$')

                add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.type, 'activity')

            end

        end

    end

    # Content motif general

    # We'll have multiple terms for the type "content-motif-general": the corresponding value from the AAT vocabulary (pref:alternate) and the value from TMS (pref:preferred)

    # Loop over the different subject terms from TMS

    do list(path:or_record.subjectWrap.db.subjects, var:s)

        # Add type of LIDO subject

        add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.type, "content-motif-general")

        # Add each subject term from TMS to LIDO subjectConcept as LIDO term (pref:preferred) along with the termID from TMS as LIDO conceptID (pref:preferred)

        lido_term(
            descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$append,
            s.subject,
            -conceptid: s.TermID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        # Retrieve the corresponding term and URI from the AAT vocabulary

        copy_field(s.subject, s.aat)
        downcase(s.aat)
        lookup_in_store(s.aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO subjectConcept as LIDO term (pref:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (pref:alternate)

        if all_match(s.aat.aatterm, '.*\S.*')

            if all_match(s.aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                    s.aat.aatterm,
                    -conceptid: s.aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                    s.aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

    # Iconclass

    # Split separate iconclass concepts from notes

    split_field(or_record.iconclass, '(\r\n|\r|\n)')

    # Loop over the different iconclass concepts from TMS

    do list(path:or_record.iconclass, var:ic)

        # Remove unnecessary whitespaces

        trim(ic)

        # Condition if the iconclass concept matches a format like "11H(AUGUSTINE)343(+3)"

        if all_match(ic, '^\d(?:\d(?:([A-Z])(?:\1)?\d*)?)?\([^\+][^\)]*\)\d*(?:\(\+\d+\))?$')

            # Add a new, empty LIDO subjectSet field

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append)

            # Retrieve iconclass ID and term from the iconclass concept

            parse_text(ic, '(^\d(?:\d(?:([A-Z])(?:\2)?\d*)?)?\(([^\+][^\)]*)\)\d*(?:\(\+\d+\))?)$')

            copy_field(ic.0, or_record.iconclassId)
            copy_field(ic.2, or_record.iconclassTerm)

            # Downcase the iconclass term

            downcase(or_record.iconclassTerm)

            ## Create the LIDO fields

            # Add iconclass ID from TMS as LIDO conceptID

            copy_field(or_record.iconclassId, descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID._)

            # Add type of LIDO conceptID

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.type, local)

            # Add source of LIDO conceptID

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.source, Iconclass)

            # Add iconclass term from TMS as LIDO term

            copy_field(or_record.iconclassTerm, descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.term.$append._)

        # Condition if the iconclass concept matches a format like "47(+22)"

        elsif all_match(ic, '^\d(?:\d(?:([A-Z])(?:\1)?\d*)?)?(?:\(\+\d+\))?$')

            # Add a new, empty LIDO subjectSet field

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append)

            # Copy the iconclass ID from the iconclass concept

            copy_field(ic, or_record.iconclassId)

            ## Create the LIDO fields

            # Add iconclass ID from TMS as LIDO conceptID

            copy_field(or_record.iconclassId, descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID._)

            # Add type of LIDO conceptID

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.type, local)

            # Add source of LIDO conceptID

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.source, Iconclass)

        # Condition if the iconclass concept matches a format like "61B2(A. PAUWELS)11(+513) profiel"

        elsif all_match(ic, '^\d(?:\d(?:([A-Z])(?:\1)?\d*)?)?\([^\+][^\)]*\)\d*(?:\(\+\d+\))? [^\d].*$')

            # Add a new, empty LIDO subjectSet field

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append)

            # Retrieve iconclass ID, term and catogory from the iconclass concept

            parse_text(ic, '^(\d(?:\d(?:([A-Z])(?:\2)?\d*)?)?\(([^\+][^\)]*)\)\d*(?:\(\+\d+\))?) ([^\d].*)$')

            copy_field(ic.0, or_record.iconclassId)
            copy_field(ic.2, or_record.iconclassTerm)
            copy_field(ic.3, or_record.iconclassCategory)

            # Downcase the iconclass term and remove unnecessary whitespaces from the iconclass category

            downcase(or_record.iconclassTerm)
            trim(or_record.iconclassCategory)

            ## Create the LIDO fields

            # Add iconclass ID from TMS as LIDO conceptID

            copy_field(or_record.iconclassId, descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID._)

            # Add type of LIDO conceptID

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.type, local)

            # Add source of LIDO conceptID

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.source, Iconclass)

            # Add iconclass term from TMS as LIDO term

            copy_field(or_record.iconclassTerm, descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.term.$append._)

            # Add iconclass category from TMS as LIDO term

            copy_field(or_record.iconclassCategory, descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.term.$append._)

        # Condition if the iconclass concept matches a format like "47C21(+8) uitgraven, landbouw"

        elsif all_match(ic, '^\d(?:\d(?:([A-Z])(?:\1)?\d*)?)?(?:\(\+\d+\))? [^\d].*$')

            # Add a new, empty LIDO subjectSet field

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append)

            # Retrieve iconclass ID and category from the iconclass concept

            parse_text(ic, '^(\d(?:\d(?:([A-Z])(?:\2)?\d*)?)?(?:\(\+\d+\))?) ([^\d].*)$')

            copy_field(ic.0, or_record.iconclassId)
            copy_field(ic.2, or_record.iconclassCategory)

            # Remove unnecessary whitespaces from the iconclass category

            trim(or_record.iconclassCategory)

            ## Create the LIDO fields

            # Add iconclass ID from TMS as LIDO conceptID

            copy_field(or_record.iconclassId, descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID._)

            # Add type of LIDO conceptID

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.type, local)

            # Add source of LIDO conceptID

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.source, Iconclass)

            # Add iconclass category from TMS as LIDO term

            copy_field(or_record.iconclassCategory, descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.term.$append._)

        # Condition if the iconclass concept matches a format like "480(+354) Tekenkunst"

        elsif all_match(ic, '^480(?:\(\+\d+\))? [^\d].*$')

            # Add a new, empty LIDO subjectSet field

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append)

            # Retrieve iconclass ID and category from the iconclass concept

            parse_text(ic, '^(480(?:\(\+\d+\))?) ([^\d].*)$')

            copy_field(ic.0, or_record.iconclassId)
            copy_field(ic.1, or_record.iconclassCategory)

            ## Create the LIDO fields

            # Add iconclass ID from TMS as LIDO conceptID

            copy_field(or_record.iconclassId, descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID._)

            # Add type of LIDO conceptID

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.type, local)

            # Add source of LIDO conceptID

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.conceptID.source, Iconclass)

            # Add iconclass category from TMS as LIDO term

            copy_field(or_record.iconclassCategory, descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last.term.$append._)

        end

        # Prevent reusing the same values in the next iteration

        remove_field(or_record.iconclassId)
        remove_field(or_record.iconclassTerm)
        remove_field(or_record.iconclassCategory)

    end

# LIDO relatedWorksWrap

    # Loop over the different relations from TMS

    do list(path:or_record.relationWrap.db.relations, var:r)

        # Add a new, empty LIDO relationWorkSet field along with page number of related object from TMS (if present) as LIDO sortorder

        add_field(descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$append)

        if all_match(r.descriptionNumbering, 'paginanummer')

            if all_match(r.numbering, '[0-9]+')

                copy_field(r.numbering, descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.sortorder)

            end

        end

        # Add object number of related object from TMS as LIDO objectID

        lido_baseid(
            descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWork.object.objectID,
            r.relatedObjectNumber,
            -type: local,
            -source: TMS
        )

        # Reconstruate datahub record ID for related object (if exists)

        copy_field(r.relatedObjectNumber, r.relatedOaiPid)
        lookup_in_store(r.relatedOaiPid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.datapids.sqlite')
        parse_text(r.relatedOaiPid.dataPid, '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
        join_field(r.relatedOaiPid.dataPid, ':')
        prepend(r.relatedOaiPid.dataPid, 'oai:datahub.kmska.be:')

        # Add the reconstruated datahub record ID as LIDO objectID

        if all_match(r.relatedOaiPid.dataPid, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWork.object.objectID,
                r.relatedOaiPid.dataPid,
                -type: oai
            )

        end

        # Determine the English relationship terms and corresponding URI conform Dublin Core (if present)

        if all_match(r.relationshipID1, '.*\S.*')

            copy_field(r.relationshipID1, r.relationshipID)

            if all_match(r.relationshipID1, '0')
                set_field(r.relationshipEn, 'Has Part')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/hasPart')
            elsif all_match(r.relationshipID1, '3')
                set_field(r.relationshipEn, 'References')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/references')
            elsif all_match(r.relationshipID1, '6')
                set_field(r.relationshipEn, 'Back')
            elsif all_match(r.relationshipID1, '8')
                set_field(r.relationshipEn, 'Is Part Of')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/isPartOf')
            else
                set_field(r.relationshipEn, 'Relation')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/relation')
            end

        else

            copy_field(r.relationshipID2, r.relationshipID)

            if all_match(r.relationshipID2, '0')
                set_field(r.relationshipEn, 'Is Part Of')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/isPartOf')
            elsif all_match(r.relationshipID2, '3')
                set_field(r.relationshipEn, 'Is Referenced By')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/isReferencedBy')
            elsif all_match(r.relationshipID2, '6')
                set_field(r.relationshipEn, 'Front')
            elsif all_match(r.relationshipID2, '8')
                set_field(r.relationshipEn, 'Has Part')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/hasPart')
            else
                set_field(r.relationshipEn, 'Relation')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/relation')
            end

        end

        # Add relationship term from TMS to LIDO relatedWorkRelType as LIDO term along with the relationshipID from TMS as LIDO conceptID

        lido_term(
            descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWorkRelType,
            r.relationship,
            -conceptid: r.relationshipID,
            -source: TMS,
            -type: local
        )

        # Add English relationship term to LIDO relatedWorkRelType as LIDO term along with the URI from Dublin Core (if present) as LIDO conceptID

        if all_match(r.relationshipURI, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWorkRelType,
                r.relationshipEn,
                -conceptid: r.relationshipURI,
                -type: URI,
                -pref: preferred,
                -lang: en
            )

        else

            lido_term(
                descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWorkRelType,
                r.relationshipEn,
                -pref: preferred,
                -lang: en
            )

        end

    end

    # Add each library link from TMS (if present) to LIDO relatedWorkSet as LIDO objectWebResource

    if all_match('or_record.linkLibrary', '.*\S.*')

        # Add a new, empty LIDO relationWorkSet field

        add_field(descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$append)

        # Create library link

        prepend(or_record.linkLibrary, 'http://anet.be/record/opackmska/')

        # Add the created library link to last created LIDO relatedWorkSet

        lido_basevalue(
            descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWork.object.objectWebResource,
            or_record.linkLibrary,
            -label: link-library
        )

    end

    # Loop over the different archive links from TMS

    do list(path:or_record.linkArchive.db.linkarchive, var:l)

        # Add each archive link from TMS (if present) to LIDO relatedWorkSet as LIDO objectWebResource

        if all_match('l.link', '.*\S.*')

            # Add a new, empty LIDO relationWorkSet field

            add_field(descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$append)

            # Create archive link

            prepend(l.link, 'http://anet.be/isadtree/kmska/opackmskaisad/')

            # Add the created archive link to last created LIDO relatedWorkSet

            lido_basevalue(
                descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWork.object.objectWebResource,
                l.link,
                -label: link-archive
            )

        end

    end



### LIDO administrativeMetadata

# LIDO rightsWorkWrap

    # Loop over the different constituents from TMS

    do list(path:or_record.constituentWrap.db.constituents, var:c)

        # Copy the copyright notice for each constituent from TMS

        copy_field(c.copyright, or_record.copyrights.$append)

    end

    # Loop over the created array with copyright notices

    do list(path:or_record.copyrights, var: c)

        # Remove unnecessary whitespaces

        trim(c)

        # If one of the copyright notices contains "SABAM", use this copyright notice

        if all_match(c, '.*SABAM.*')

            copy_field(c, or_record.copyright)

        else

            unless exists(or_record.copyright)

                copy_field(c, or_record.copyright)

            end

        end

    end

    # If the copyright notice is "CC0", add this to LIDO rightsType as LIDO term along with the URI from creativecommons.org as LIDO conceptID

    if all_match(or_record.copyright, 'CC0')

        set_field(or_record.copyrightUrl, 'https://creativecommons.org/publicdomain/zero/1.0/')

        lido_term(
            administrativeMetadata.rightsWorkWrap.rightsWorkSet.rightsType,
            or_record.copyright,
            -conceptid: or_record.copyrightUrl,
            -source: 'Creative Commons',
            -type: 'purl'
        )

    end

    # Add the copyright notice to LIDO creditLine

    if all_match(or_record.copyright, '.*\S.*')

        lido_basevalue(
            administrativeMetadata.rightsWorkWrap.rightsWorkSet.creditLine,
            or_record.copyright
        )

    end

# LIDO recordID

    # Add datapid from TMS as LIDO recordID (type:global)

    lido_baseid(
        administrativeMetadata.recordWrap.recordID,
        or_record.object_number.pid.dataPid,
        -type: global
    )

    # Add object number from TMS as LIDO recordID (type:local)

    lido_baseid(
        administrativeMetadata.recordWrap.recordID,
        or_record.object_number.tms,
        -type: local
    )

# LIDO recordType

    # Create AATRecordTypeTerm and AATRecordTypeID

    add_field('or_record.AATRecordTypeTerm', 'Item')
    add_field('or_record.AATRecordTypeID', 'http://vocab.getty.edu/aat/300133025')

    # Add the created AATRecordTypeTerm to LIDO recordType as LIDO term along with the AATRecordTypeID as LIDO conceptID

    lido_term(
        administrativeMetadata.recordWrap.recordType,
        or_record.AATRecordTypeTerm,
        -conceptid: or_record.AATRecordTypeID,
        -type: local,
        -source: AAT
    )

# LIDO recordSource

    # Add department ID from TMS to LIDO recordSource as LIDO legalBodyID

    lido_baseid(
        administrativeMetadata.recordWrap.recordSource.legalBodyID,
        or_record.department.db.DepartmentID,
        -type: local,
        -source: TMS
    )

    # Add department from TMS to LIDO recordSource as LIDO legalBodyName

    lido_basenameset(
        administrativeMetadata.recordWrap.recordSource.legalBodyName,
        or_record.department.db.department
    )

    # Create legalBodyWeblink

    add_field(or_record.legalBodyWeblink, 'http://kmska.be')

    # Add the created legalBodyWeblink to LIDO recordSource as LIDO legalBodyWeblink

    lido_basevalue(
        administrativeMetadata.recordWrap.recordSource.legalBodyWeblink,
        or_record.legalBodyWeblink
    )


## LIDO resourceWrap

# LIDO resourceID & linkResource

    # Add representationpid from TMS (if present) to LIDO resourceSet as LIDO resourceID and as LIDO linkResource

    if all_match(or_record.object_number.pid.representationPid, '.*\S.*')

        copy_field(or_record.object_number.pid.representationPid, administrativeMetadata.resourceWrap.resourceSet.resourceID._)
        add_field(administrativeMetadata.resourceWrap.resourceSet.resourceID.type, "purl")
        add_field(administrativeMetadata.resourceWrap.resourceSet.resourceID.label, "representationPID")

        copy_field(or_record.object_number.pid.representationPid, administrativeMetadata.resourceWrap.resourceSet.resourceRepresentation.linkResource._)

    end



### Add lang attributes to descriptiveMetadata and administrativeMetadata

    add_field(descriptiveMetadata.lang, 'nl')
    add_field(administrativeMetadata.lang, 'nl')



### Add empty values for required LIDO elements/attributes if not already exist

    unless exists(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType)
        add_field(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.term._, "")
    end



### Remove the 'or_record' structure

    remove_field(or_record)
