# Catmandu Fix

# Institution: Royal Museum for Fine Arts Antwerp
# Description: Converts TMS datastructures to LIDO 1.0
# Created: 8/11/2017



### Prepare an intermediate structure

# Retain only those records where DepartmentID equals 1

    select all_match(DepartmentID, '1')

# Copy relevant fields in order to create a dedicated LIDO structure
# Some fields, for example ObjectNumber, ObjectID, DateBegin, DateEnd, Dated and Medium, are obtained from the CITvgsrpObjTombstoneD_RO table in MySQL
# Additional data is obtained from SQLite database files

    # Identifiers

    copy_field(ObjectNumber, or_record.object_number.local)

    copy_field(ObjectID, or_record.object_number.tms)

    copy_field(ObjectNumber, or_record.object_number.datapid)
    lookup_in_store(or_record.object_number.datapid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.datapids.sqlite')
    move_field(or_record.object_number.datapid.dataPid, or_record.object_number.pid.dataPid)
    remove_field(or_record.object_number.datapid)

    copy_field(ObjectNumber, or_record.object_number.workpid)
    lookup_in_store(or_record.object_number.workpid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.workpids.sqlite')
    move_field(or_record.object_number.workpid.workPid, or_record.object_number.pid.workPid)
    remove_field(or_record.object_number.workpid)

    copy_field(ObjectNumber, or_record.object_number.representationpid)
    lookup_in_store(or_record.object_number.representationpid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.representationpids.sqlite')
    move_field(or_record.object_number.representationpid.representationPid, or_record.object_number.pid.representationPid)
    remove_field(or_record.object_number.representationpid)

    # objectWrap

    copy_field(ObjectID, or_record.objectWrap.db)
    lookup_in_store(or_record.objectWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.objects.sqlite')

    # classificationWrap

    copy_field(ObjectID, or_record.classificationWrap.db)
    lookup_in_store(or_record.classificationWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.classifications.sqlite')

    # subjectWrap

    copy_field(ObjectID, or_record.subjectWrap.db)
    lookup_in_store(or_record.subjectWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.subjects.sqlite')

    # materialWrap

    copy_field(ObjectID, or_record.materialWrap.db)
    lookup_in_store(or_record.materialWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.materials.sqlite')

    # techniqueWrap

    copy_field(ObjectID, or_record.techniqueWrap.db)
    lookup_in_store(or_record.techniqueWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.techniques.sqlite')

    # title

    copy_field(ObjectNumber, or_record.titleWrap.db)
    lookup_in_store(or_record.titleWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.objtitles.sqlite')

    # description

    copy_field(ObjectID, or_record.description.db)
    lookup_in_store(or_record.description.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.descriptions.sqlite')
    trim(or_record.description.db.description)

    # objectMeasurements

    copy_field(ObjectID, or_record.objectMeasurements.db)
    lookup_in_store(or_record.objectMeasurements.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.dimensions.sqlite')

    # production actor (production)

    copy_field(ObjectID, or_record.constituentWrap.db)
    lookup_in_store(or_record.constituentWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.constituents.sqlite')

    # production date (production)

    unless all_equal(DateBegin, '0')
        copy_field(DateBegin, or_record.date.begin)
    end

    unless all_equal(DateEnd, '0')
        copy_field(DateEnd, or_record.date.end)
    end

    copy_field(Dated, or_record.date.display)

    trim(or_record.date.begin)
    trim(or_record.date.end)
    trim(or_record.date.display)

    # period

    copy_field(ObjectID, or_record.periodName)
    lookup_in_store(or_record.periodName, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.periods.sqlite')

    # place (not yet added)

    # eventMaterialsTech

    copy_field(Medium, or_record.eventMaterialsTech.display)

    # subjectConcept

    copy_field(ObjectID, or_record.iconclass.db)
    lookup_in_store(or_record.iconclass.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.iconclass.sqlite')

    # relatedWorksWrap

    copy_field(ObjectID, or_record.relationWrap.db)
    lookup_in_store(or_record.relationWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.relations.sqlite')

    # recordSource

    copy_field(ObjectID, or_record.department.db)
    lookup_in_store(or_record.department.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.departments.sqlite')

# Remove all fields from CITvgsrpObjTombstoneD_RO, retaining only the ones necessary to create the LIDO structure

    retain(or_record)



### Mapping to lido structure

# Mapping Facets
# ---------------------------------------------------------------------------------------------------------------------------------------------------
# TMS - MySQL                             LIDO                                                VKC                     Invulboek veld
#                                             lido:lidoRecID
#   vdatapids.dataPid                             type: purl                                                              waarde databanknummer
#                                                 type: urn
#   vworkpids.workPid                         lido:objectPublishedID                              Work PURL               waarde objectnummer
#                                             lido:category
#                                                 lido:conceptID
#                                                 lido:term
#                                             lido:objectWorkType
#                                                 lido:conceptID
#   vobjects.TermID                                  pref: preferred
#                                                    pref: alternate                                                      identificatie objectnaam
#                                                 lido:term
#   vobjects.object                                  pref: preferred                              Subtype                 term objectnaam
#                                                    pref: alternate                              Subtype
#                                             lido:classification
#                                                 type: object-category
#                                                    lido:conceptID
#   vclassifications.ClassificationID                     pref: preferred
#                                                         pref: alternate                                                 identificatie
#                                                    lido:term
#   vclassifications.Classification                       pref: preferred                         Type                    term
#                                                         pref: alternate                         Type
#                                             lido:titleSet
#                                                 lido:appellationValue
#   vobjtitles.title                                  lang: en                                                            titel
#   vobjtitles.title                                  lang: nl                                                            titel
#                                                 lido:sourceAppellation
#   vobjtitles.titleid                                lang: en
#   vobjtitles.titleid                                lang: nl
#                                             lido:repositorySet
#                                                 lido:repositoryName
#   vdepartments.DepartmentID                         lido:legalBodyID
#   vdepartments.department                           lido:legalBodyName                          Instelling              naam bewaarinstelling
#                                                 lido:workID
#   CITvgsrpObjTombstoneD_RO.ObjectNumber             type: object-number                         Inventarisnummer        waarde objectnummer
#   vdescriptions.description                 lido:objectDescriptionSet                           Beschrijving            korte beschrijving
#                                             lido:objectMeasurementsSet
#   vdimensions.display                           lido:displayObjectMeasurements
#                                                 lido:objectMeasurements
#                                                     lido:measurementsSet
#   vdimensions.type                                      lido:measurementType                                            dimensie afmeting
#   vdimensions.unit                                      lido:measurementUnit                    Dimensies               eenheid afmeting
#   vdimensions.dimension                                 lido:measurementValue                   Dimensies               waarde afmeting
#   vdimensions.element                               lido:extentMeasurements                                             onderdeel afmeting
#                                             lido:eventType
#                                                 lido:term
#                                                     production
#                                                         lido:eventActor
#                                                             lido:actorID
#   vconstituents.ConstituentID                                   type: local
#                                                                 type: purl                                              identificatie vervaardiger
#                                                             lido:nameActorSet
#   vconstituents.DisplayName                                     pref: preferred                 Vervaardiger            naam vervaardiger
#                                                                 pref: alternate
#                                                             lido:vitalDatesActor
#   vconstituents.BeginDateISO                                    lido:earliestDate
#   vconstituents.EndDateISO                                      lido:latestDate
#   vconstituents.Role                                        lido:roleActor                      Vervaardiger            rol vervaardiger
#   vconstituents.Role                                        lido:attributionQualifierActor      Vervaardiger            kwalificatie vervaardiger
#                                                         lido:eventDate
#   CITvgsrpObjTombstoneD_RO.Dated                            lido:displayDate                    Datering
#                                                             lido:date
#   CITvgsrpObjTombstoneD_RO.DateBegin                            lido:earliestDate                                       begindatum
#   CITvgsrpObjTombstoneD_RO.DateEnd                              lido:latestDate                                         einddatum
#                                                         lido:periodName
#   vperiods.term                                             lido:term
#                                                         lido:eventMaterialsTech
#                                                             lido:termMaterialsTech
#                                                                 type: material
#                                                                     lido:conceptID
#   vmaterials.TermID                                                     pref: preferred
#                                                                         pref: alternate                                 identificatie materiaal
#                                                                     lido:term
#   vmaterials.material                                                   pref: preferred         Materiaal               term materiaal
#                                                                         pref: alternate
#                                                                 type: technique
#                                                                     lido:conceptID
#   vtechniques.TermID                                                    pref: preferred
#                                                                     lido:term
#   vtechniques.technique                                                 pref: preferred
#   CITvgsrpObjTombstoneD_RO.Medium                           lido:displayMaterialsTech
#                                             lido:objectRelationWrap
#                                                 lido:subject
#                                                     type: content-motif-general
#                                                         lido:subjectConcept
#                                                             lido:conceptID
#   vsubjects.TermID                                              pref: preferred
#                                                                 pref: alternate                                         identificatie hoofdmotief
#                                                             lido:term
#   vsubjects.subject                                             pref: preferred                 Onderwerp               term hoofdmotief
#                                                                 pref: alternate                 Onderwerp
#                                                     source: Iconclass
#                                                         lido:subjectConcept
#   viconclass                                                lido:conceptID                                              identificatie afgebeeld concept
#   viconclass                                                lido:term                                                   term afgebeeld concept
#                                             lido:relatedWorksWrap
#                                                 lido:relatedWorkSet
#   vrelations.numbering                              sortorder
#                                                         lido:objectID
#   vrelations.relatedObjectNumber                            type: local
#                                                             type: oai
#                                                 lido:relatedWorkRelType
#   vrelations.relationshipID1(2)                     lido:conceptID
#                                                         type: local
#                                                         type: URI
#   vrelations.relationship                           lido:term
#                                             lido:rightsWorkWrap
#                                                 lido:rightsType
#                                                     lido:conceptID                                                      identificatie rechten werk
#   vconstituents.copyright                           lido:term                                                           term rechten werk
#   vconstituents.copyright                       lido:creditLine
#                                             lido:recordWrap
#                                                 lido:recordID
#   vdatapids.dataPid                                 type: global                                Data PURL               waarde databanknummer
#   CITvgsrpObjTombstoneD_RO.ObjectID                 type: local                                                         waarde databanknummer
#                                                 lido:recordType
#                                                     lido:conceptID
#                                                     lido:term
#                                                 lido:recordSource
#   vdepartments.DepartmentID                         lido:legalBodyID                                                    identificatie data provider
#   vdepartments.department                           lido:legalBodyName                                                  naam data provider
#                                                     lido:legalBodyWeblink
#                                             lido:resourceWrap
#   vrepresentationpids.representationPid         lido:resourceID
#                                                 lido:resourceRepresentation
#   vrepresentationpids.representationPid             lido:linkResource



### LIDO lidoRecID

    # ID
    #
    # The ID in Solr is based on the data_pid. The data_pid is converted to a string
    # which can be safely used as an identifier in Project Blacklight. The format of
    # the ID field looks like this:
    #
    #   oai:datahub.vlaamsekunstcollectie.be:<domain>:<identifier>
    #   ex. oai:datahub.vlaamsekunstcollectie.be:kmksa.be:254
    #   ex. oai:datahub.vlaamsekunstcollectie.be:collectievlaamsegemeenschap.be:837
    #
    # Note: the .tld is stripped from the domainname because the . (dot) breaks the
    # route matching algoritm.

    # Create datahub record ID

    copy_field('or_record.object_number.pid.dataPid', 'or_record.object_number.pid.oaiPid')
    parse_text('or_record.object_number.pid.oaiPid', '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
    join_field('or_record.object_number.pid.oaiPid', ':')
    prepend('or_record.object_number.pid.oaiPid', 'oai:datahub.vlaamsekunstcollectie.be:')

    # Add datapid from TMS as LIDO lidoRecID (type:purl)

    lido_baseid(
        lidoRecID,
        or_record.object_number.pid.dataPid,
        -type: purl,
        -source: 'Koninklijk Museum voor Schone Kunsten Antwerpen',
        -label: dataPID,
        -pref: alternate
    )

    # Add the created datahub record ID as LIDO lidoRecID (type:urn)

    lido_baseid(
        lidoRecID,
        or_record.object_number.pid.oaiPid,
        -type: urn,
        -source: 'Vlaamse Kunstcollectie - Arthub Flanders',
        -label: dataPID,
        -pref: preferred
    )



### LIDO objectPublishedID

    # Add workpid from TMS as LIDO objectPublishedID

    lido_baseid(
        objectPublishedID,
        or_record.object_number.pid.workPid,
        -source: 'Koninklijk Museum voor Schone Kunsten Antwerpen',
        -type: purl,
        -label: workPID
    )



### LIDO category

    # Create CIDOCCategoryTerm and CIDOCCategoryURI

    add_field(or_record.CIDOCCategoryTerm, 'Man-Made Object')
    add_field(or_record.CIDOCCategoryURI, 'http://www.cidoc-crm.org/Entity/e22-man-made-object/version-6.1')

    # Add the created CIDOCCategoryTerm to LIDO category as LIDO term along with the CIDOCCategoryURI as LIDO conceptID

    lido_term(
        category,
        or_record.CIDOCCategoryTerm,
        -conceptid: or_record.CIDOCCategoryURI,
        -type: purl,
        -source: cidoc-crm
    )



### LIDO descriptiveMetadata

## LIDO objectClassificationWrap

# LIDO objectWorkType

    # We'll have multiple terms: the corresponding value from the AAT vocabulary (type:alternate) and the value from TMS (type:preferred)

    # Loop over the different object terms from TMS

    do list(path:or_record.objectWrap.db.objects, var:o)

        # Add each object term from TMS to LIDO objectWorkType as LIDO term (type:preferred) along with the termID from TMS as LIDO conceptID (type:preferred)

        lido_term(
            descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$append,
            o.object,
            -conceptid: o.TermID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        # Retrieve the corresponding term and URI from the AAT vocabulary, these are not (yet) retrievable via TMS

        copy_field(o.object, o.object_aat)
        lookup_in_store(o.object_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO objectWorkType as LIDO term (type:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (type:alternate)

        if all_match(o.object_aat.aatterm, '.*\S.*')

            if all_match(o.object_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                    o.object_aat.aatterm,
                    -conceptid: o.object_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                    o.object_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )                

            end

        end

    end

# LIDO classification [type="object-category"]

    # We'll have multiple terms for the type "object-category": the corresponding value from the AAT vocabulary (type:alternate) and the value from TMS (type:preferred)

    # Loop over the different classification terms from TMS

    do list(path:or_record.classificationWrap.db.classifications, var:c)

        # Add each classification term from TMS to LIDO classification as LIDO term (type:preferred) along with the classificationID from TMS as LIDO conceptID (type:preferred)

        lido_term(
            descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$append,
            c.Classification,
            -conceptid: c.ClassificationID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        # Add type of LIDO classification

        add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.type, "object-category")

        # Retrieve the corresponding term and URI from the AAT vocabulary, these are not (yet) retrievable via TMS

        copy_field(c.Classification, c.classification_aat)
        lookup_in_store(c.classification_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO classification as LIDO term (type:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (type:alternate)

        if all_match(c.classification_aat.aatterm, '.*\S.*')

            if all_match(c.classification_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last,
                    c.classification_aat.aatterm,
                    -conceptid: c.classification_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last,
                    c.classification_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )                

            end

            # Add type of LIDO classification

            add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.type, "object-category")

        end

    end


## LIDO objectIdentificationWrap

# LIDO titleSet

    # Loop over the different titles from TMS

    do list(path:or_record.titleWrap.db.objtitles, var:t)

        # Use TitleTypeID 1 (titles)

        if all_match(t.titletypeid, '1')

            # Remove unnecessary whitespaces

            trim(t.title)
            trim(t.titleid)

            # Add each title from TMS to LIDO titleSet as LIDO appellationValue along with the titleID from TMS as LIDO sourceAppellation

            copy_field(t.title, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$append._)
            set_field(descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$last.pref, 'preferred')
            copy_field(t.language, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$last.lang)
            copy_field(t.titleid, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.sourceAppellation.$append._)
            copy_field(t.language, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.sourceAppellation.$last.lang)

        end

    end

# LIDO repositoryName

    # Add department ID from TMS to LIDO repositoryName as LIDO legalBodyID

    lido_baseid(
        descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$append.repositoryName.legalBodyID,
        or_record.department.db.DepartmentID,
        -type: local,
        -source: TMS
    )

    # Add department from TMS to LIDO repositoryName as LIDO legalBodyName

    lido_basenameset(
        descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryName.legalBodyName,
        or_record.department.db.department
    )

    if all_match(or_record.legalBodyName, '.*\S.*')

        lido_basenameset(
            descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.repositoryName.legalBodyName,
            or_record.legalBodyName
        )

    end

# LIDO workID

    # Add object number from TMS as LIDO workID

    lido_baseid(
        descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.workID,
        or_record.object_number.local,
        -type: object-number
    )

# LIDO objectDescriptionSet

    # Add description from TMS (if present) as LIDO descriptiveNoteValue

    if all_match(or_record.description.db.description, '.*\S.*')

        lido_descriptivenote(
            descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet,
            or_record.description.db.description,
            -lang: 'nl'
        )

    end

# LIDO objectMeasurementsSet

    # Loop over the different dimensions from TMS

    do list(path:or_record.objectMeasurements.db.dimensions, var:d)

        # Add a new, empty LIDO objectMeasurementsSet field

        add_field(descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$append)

        ## Create the LIDO fields

        # Add display of each dimension from TMS (if present) as LIDO displayObjectMeasurements

        if all_match(d.display, '.*\S.*')

            copy_field(d.display, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.displayObjectMeasurements._)

        end

        # Add type of each dimension from TMS (if present) as LIDO measurementType

        if all_match(d.type, '.*\S.*')

            copy_field(d.type, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementType._)

        end

        # Add unit of each dimension from TMS (if present) as LIDO measurementUnit

        if all_match(d.unit, '.*\S.*')

            copy_field(d.unit, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementUnit._)

        end

        # Add value of each dimension from TMS (if present) as LIDO measurementValue

        if all_match(d.dimension, '.*\S.*')

            copy_field(d.dimension, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementValue._)

        end

        # Add element of each dimension from TMS (if present) as LIDO extentMeasurements

        if all_match(d.element, '.*\S.*')

            copy_field(d.element, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.extentMeasurements._)

        end

    end


## LIDO eventWrap

# LIDO eventType

    # Create event_type

    add_field(or_record.event_type, "production")

    # Add the created event type to LIDO eventType
    
    lido_term(
        descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
        or_record.event_type
    )

# LIDO eventActor

    # We'll have multiple appellationValues and actorIDs for the same actor: the corresponding values from the creators vocabulary and the values from TMS

    # Determine which roles from TMS should be added as qualifier

    set_array(qualifiers, "atelier van", "kopie naar", "navolger van", "omgeving van", "school van", "toegeschreven aan", "vroegere toeschrijving", "x")

    # Loop over the different constituents from TMS

    do list(path:or_record.constituentWrap.db.constituents, var:c)

        # Remove unnecessary whitespaces

        trim(c.BeginDateISO)
        trim(c.EndDateISO)

        # Add the display name of each constituent from TMS to LIDO eventActor as LIDO appellationValue (type:preferred)
        # along with the constituentID from TMS as LIDO actorID (source:TMS),
        # the BeginDateISO from TMS as LIDO earliestDate,
        # the EndDateISO from TMS as LIDO latestDate and,
        # if determined before as qualifier, add the Role from TMS as LIDO attributionQualifierActor
        # else, add the Role from TMS as LIDO roleActor

        if in(c.Role, qualifiers)
            lido_actor(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append,
                c.ConstituentID,
                c.DisplayName,
                -id_source: TMS,
                -id_type: local,
                -qualifier: c.Role,
                -name_pref: preferred
            )
        else
            lido_actor(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append,
                c.ConstituentID,
                c.DisplayName,
                -id_source: TMS,
                -id_type: local,
                -birthdate: c.BeginDateISO,
                -deathdate: c.EndDateISO,
                -role: c.Role,
                -name_pref: preferred
            )
        end

        # Retrieve the corresponding values from the creators vocabulary, these are not (yet) retrievable via TMS

        copy_field(c.DisplayName, c.creator.pid)
        downcase(c.creator.pid)
        lookup_in_store(c.creator.pid, DBI, data_source: "dbi:SQLite:/tmp/import.CREATORS_UTF8.sqlite")

        # Add the corresponding display name from the creators vocabulary (if present) to LIDO eventActor as LIDO appellationValue (type:alternate)

        if all_match(c.creator.pid._id, '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.nameActorSet.$last,
                c.creator.pid.display_name,
                -value_pref: alternate
            )

        end

        # Add the corresponding VIAF URI from the creators vocabulary (if present) to LIDO eventActor as LIDO actorID (source:VIAF)

        if all_match(c.creator.pid.viaf_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.viaf_uri,
                -source: VIAF,
                -type: purl
            )

        end

        # Add the corresponding RKD URI from the creators vocabulary (if present) to LIDO eventActor as LIDO actorID (source:RKD)

        if all_match(c.creator.pid.rkd_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.rkd_uri,
                -source: RKD,
                -type: purl
            )

        end

        # Add the corresponding Wikidata URI from the creators vocabulary (if present) to LIDO eventActor as LIDO actorID (source:Wikidata)

        if all_match(c.creator.pid.wikidata_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.wikidata_uri,
                -source: Wikidata,
                -type: purl
            )

        end

    end

    # Remove the created field qualifiers

    remove_field(qualifiers)

# LIDO displayDate

    # Add display date from TMS (if present) as LIDO displayDate

    if all_match(or_record.date.display, '.*\S.*')

        lido_basevalue(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.displayDate,
            or_record.date.display
        )

    end

# LIDO date

    # Add begin end end date from TMS (if present) as respectively LIDO earliestDate and LIDO latestDate

    if all_match(or_record.date.begin, '.*\S.*')

        if all_match(or_record.date.end, '.*\S.*')

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -earliest_date: or_record.date.begin,
                -latest_date: or_record.date.end
            )

        else

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -earliest_date: or_record.date.begin
            )

        end

    else

        if all_match(or_record.date.end, '.*\S.*')

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -latest_date: or_record.date.end
            )

        end

    end

# LIDO periodName

    # Add period from TMS as LIDO periodName

    lido_term(
        descriptiveMetadata.eventWrap.eventSet.$last.event.periodName,
        or_record.periodName.term,
        -lang: nl
    )

# LIDO namePlaceSet

    # Not yet added

# LIDO termMaterialsTech

    # We'll have multiple terms: the corresponding value from the AAT vocabulary (type:alternate) and the value from TMS (type:preferred)

    # Loop over the different material terms from TMS

    do list(path:or_record.materialWrap.db.materials, var:m)

        add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$append.type, "material")

        # Add each material term from TMS to LIDO termMaterialsTech as LIDO term (type:preferred) along with the termID from TMS as LIDO conceptID (type:preferred)
        
        lido_term(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
            m.material,
            -conceptid: m.TermID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        # Retrieve the corresponding term and URI from the AAT vocabulary, these are not (yet) retrievable via TMS

        copy_field(m.subject, m.material_aat)
        downcase(m.material_aat)
        lookup_in_store(m.material_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO termMaterialsTech as LIDO term (type:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (type:alternate)

        if all_match(m.material_aat.aatterm, '.*\S.*')

            if all_match(m.material_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    m.material_aat.aatterm,
                    -conceptid: m.material_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    m.material_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

    # Loop over the different technique terms from TMS

    do list(path:or_record.techniqueWrap.db.techniques, var:t)

        add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$append.type, "technique")

        # Add each technique term from TMS to LIDO termMaterialsTech as LIDO term (type:preferred) along with the termID from TMS as LIDO conceptID (type:preferred)

        lido_term(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
            t.technique,
            -conceptid: t.TermID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        # Retrieve the corresponding term and URI from the AAT vocabulary, these are not (yet) retrievable via TMS

        copy_field(t.subject, t.technique_aat)
        downcase(t.technique_aat)
        lookup_in_store(t.technique_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO termMaterialsTech as LIDO term (type:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (type:alternate)

        if all_match(t.technique_aat.aatterm, '.*\S.*')

            if all_match(t.technique_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    t.technique_aat.aatterm,
                    -conceptid: t.technique_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    t.technique_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

# LIDO displayMaterialsTech

    # Add medium from TMS as LIDO displayMaterialsTech

    if all_match(or_record.eventMaterialsTech.display, '.*\S.*')

        lido_basevalue(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.displayMaterialsTech,
            or_record.eventMaterialsTech.display
        )

    end


## LIDO objectRelationWrap

# LIDO subjectConcept

    # Content motif general

    # We'll have multiple terms for the type "content-motif-general": the corresponding value from the AAT vocabulary (type:alternate) and the value from TMS (type:preferred)

    # Loop over the different subject terms from TMS

    do list(path:or_record.subjectWrap.db.subjects, var:s)

        # Add type of LIDO subject

        add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.type, "content-motif-general")

        # Add each subject term from TMS to LIDO subjectConcept as LIDO term (type:preferred) along with the termID from TMS as LIDO conceptID (type:preferred)

        lido_term(
            descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$append,
            s.subject,
            -conceptid: s.TermID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        # Retrieve the corresponding term and URI from the AAT vocabulary, these are not (yet) retrievable via TMS

        copy_field(s.subject, s.aat)
        downcase(s.aat)
        lookup_in_store(s.aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO classification as LIDO term (type:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (type:alternate)

        if all_match(s.aat.aatterm, '.*\S.*')

            if all_match(s.aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                    s.aat.aatterm,
                    -conceptid: s.aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                    s.aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

    # Iconclass

    # Loop over the different iconclass concepts from TMS

    do list(path:or_record.iconclass.db.iconclass, var:ic)

        # Remove unnecessary whitespaces

        trim(ic)

        paste(or_record.iconclassId, ic.TermSource, ic.SourceTermID, join_char:'')

        # Add each iconclass concept from TMS to LIDO subjectConcept as LIDO term along with the iconclass ID from TMS as LIDO conceptID

        lido_term(
            descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.subjectConcept.$append,
            ic.term,
            -conceptid: or_record.iconclassId,
            -type: purl,
            -source: Iconclass,
            -lang: nl
        )

        # Prevent reusing the same values in the next iteration

        remove_field(or_record.iconclassId)

        # English term

        copy_field(ic.SourceTermID, ic.english_term)

        lookup_in_store(ic.english_term, DBI, data_source: "dbi:SQLite:/tmp/import.iconclass.sqlite")

        unless all_match(ic.english_term.t, '.*\S.*')

            if all_match(ic.english_term, '^\d(?:\d(?:([A-Z])(?:\1)?\d*)?)?\([^\+][^\)]*\)\d*(?:\(\+\d+\))?.*')

                replace_all(ic.english_term, '^(\d(?:\d(?:([A-Z])(?:\2)?\d*)?)?\()[^\+][^\)]*(\)\d*(?:\(\+\d+\))?.*)', '$1...$3')

                lookup_in_store(ic.english_term, DBI, data_source: "dbi:SQLite:/tmp/import.iconclass.sqlite")

                if all_match(ic.english_term.t, '.*\(with [^\(]*[A-Z][A-Z]+[^\(]*\).*')

                    replace_all('ic.SourceTermID', '^\d(?:\d(?:([A-Z])(?:\1)?\d*)?)?\(([^\+][^\)]*)\)\d*(?:\(\+\d+\))?.*', '$2')
                    paste(ic.english_term.t, 'ic.SourceTermID', ic.english_term.t, join_char:'##KEYWORD##')
                    replace_all(ic.english_term.t, '(.*)##KEYWORD##(.*)\(with [^\(]*[A-Z][A-Z]+[^\(]*\)(.*)', '$1##KEYWORD##$2\($1\)$3')
                    replace_all(ic.english_term.t, '(.*)##KEYWORD##(.*)\(with [^\(]*[A-Z][A-Z]+[^\(]*\)(.*)', '$1##KEYWORD##$2\($1\)$3')
                    replace_all(ic.english_term.t, '.*##KEYWORD##(.*)', '$1')

                end

            end

        end

        if all_match(ic.english_term.t, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                ic.english_term.t,
                -lang: en
            )

        end

    end

# LIDO relatedWorksWrap

    # Loop over the different relations from TMS

    do list(path:or_record.relationWrap.db.relations, var:r)

        # Add a new, empty LIDO relationWorkSet field along with page number of related object from TMS (if present) as LIDO sortorder

        add_field(descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$append)

        if all_match(r.descriptionNumbering, 'paginanummer')

            if all_match(r.numbering, '[0-9]+')

                copy_field(r.numbering, descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.sortorder)

            end

        end

        # Add object number of related object from TMS as LIDO objectID

        lido_baseid(
            descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWork.object.objectID,
            r.relatedObjectNumber,
            -type: local,
            -source: TMS
        )

        # Reconstruate datahub record ID for related object (if exists)

        copy_field(r.relatedObjectNumber, r.relatedOaiPid)
        lookup_in_store(r.relatedOaiPid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.datapids.sqlite')
        parse_text(r.relatedOaiPid.dataPid, '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
        join_field(r.relatedOaiPid.dataPid, ':')
        prepend(r.relatedOaiPid.dataPid, 'oai:datahub.vlaamsekunstcollectie.be:')

        # Add the reconstruated datahub record ID as LIDO objectID

        if all_match(r.relatedOaiPid.dataPid, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWork.object.objectID,
                r.relatedOaiPid.dataPid,
                -type: oai
            )

        end

        # Determine the English relationship terms and corresponding URI conform Dublin Core (if present)

        if all_match(r.relationshipID1, '.*\S.*')

            copy_field(r.relationshipID1, r.relationshipID)

            if all_match(r.relationshipID1, '0')
                set_field(r.relationshipEn, 'Has Part')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/hasPart')
            elsif all_match(r.relationshipID1, '3')
                set_field(r.relationshipEn, 'References')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/references')
            elsif all_match(r.relationshipID1, '6')
                set_field(r.relationshipEn, 'Back')
            elsif all_match(r.relationshipID1, '8')
                set_field(r.relationshipEn, 'Is Part Of')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/isPartOf')
            else
                set_field(r.relationshipEn, 'Relation')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/relation')
            end

        else

            copy_field(r.relationshipID2, r.relationshipID)

            if all_match(r.relationshipID2, '0')
                set_field(r.relationshipEn, 'Is Part Of')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/isPartOf')
            elsif all_match(r.relationshipID2, '3')
                set_field(r.relationshipEn, 'Is Referenced By')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/isReferencedBy')
            elsif all_match(r.relationshipID2, '6')
                set_field(r.relationshipEn, 'Front')
            elsif all_match(r.relationshipID2, '8')
                set_field(r.relationshipEn, 'Has Part')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/hasPart')
            else
                set_field(r.relationshipEn, 'Relation')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/relation')
            end

        end

        # Add relationship term from TMS to LIDO relatedWorkRelType as LIDO term along with the relationshipID from TMS as LIDO conceptID

        lido_term(
            descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWorkRelType,
            r.relationship,
            -conceptid: r.relationshipID,
            -source: TMS,
            -type: local
        )

        # Add English relationship term to LIDO relatedWorkRelType as LIDO term along with the URI from Dublin Core (if present) as LIDO conceptID

        if all_match(r.relationshipURI, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWorkRelType,
                r.relationshipEn,
                -conceptid: r.relationshipURI,
                -type: URI,
                -pref: preferred,
                -lang: en
            )

        else

            lido_term(
                descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWorkRelType,
                r.relationshipEn,
                -pref: preferred,
                -lang: en
            )

        end

    end



### LIDO administrativeMetadata

# LIDO rightsWorkWrap

    # Loop over the different constituents from TMS

    do list(path:or_record.constituentWrap.db.constituents, var:c)

        # Copy the copyright notice for each constituent from TMS

        copy_field(c.copyright, or_record.copyrights.$append)

    end

    # Loop over the created array with copyright notices

    do list(path:or_record.copyrights, var: c)

        # Remove unnecessary whitespaces

        trim(c)

        # If one of the copyright notices contains "SABAM", use this copyright notice

        if all_match(c, '.*SABAM.*')

            copy_field(c, or_record.copyright)

        else

            unless exists(or_record.copyright)

                copy_field(c, or_record.copyright)

            end

        end

    end

    # If the copyright notice is "CC0", add this to LIDO rightsType as LIDO term along with the URI from creativecommons.org as LIDO conceptID

    if all_match(or_record.copyright, 'CC0')

        set_field(or_record.copyrightUrl, 'https://creativecommons.org/publicdomain/zero/1.0/')

        lido_term(
            administrativeMetadata.rightsWorkWrap.rightsWorkSet.rightsType,
            or_record.copyright,
            -conceptid: or_record.copyrightUrl,
            -source: 'Creative Commons',
            -type: 'purl'
        )

    end

    # Add the copyright notice to LIDO creditLine

    if all_match(or_record.copyright, '.*\S.*')

        lido_basevalue(
            administrativeMetadata.rightsWorkWrap.rightsWorkSet.creditLine,
            or_record.copyright
        )

    end

# LIDO recordID

    # Add datapid from TMS as LIDO recordID (type:global)

    lido_baseid(
        administrativeMetadata.recordWrap.recordID,
        or_record.object_number.pid.dataPid,
        -type: global
    )

    # Add object number from TMS as LIDO recordID (type:local)

    lido_baseid(
        administrativeMetadata.recordWrap.recordID,
        or_record.object_number.tms,
        -type: local
    )

# LIDO recordType

    # Create AATRecordTypeTerm and AATRecordTypeID

    add_field('or_record.AATRecordTypeTerm', 'Item')
    add_field('or_record.AATRecordTypeID', 'http://vocab.getty.edu/aat/300133025')

    # Add the created AATRecordTypeTerm to LIDO recordType as LIDO term along with the AATRecordTypeID as LIDO conceptID

    lido_term(
        administrativeMetadata.recordWrap.recordType,
        or_record.AATRecordTypeTerm,
        -conceptid: or_record.AATRecordTypeID,
        -type: local,
        -source: AAT
    )

# LIDO recordSource

    # Add department ID from TMS to LIDO recordSource as LIDO legalBodyID

    lido_baseid(
        administrativeMetadata.recordWrap.recordSource.legalBodyID,
        or_record.department.db.DepartmentID,
        -type: local,
        -source: TMS
    )

    # Add department from TMS to LIDO recordSource as LIDO legalBodyName

    unless all_match(or_record.legalBodyName, '.*\S.*')
        add_field(or_record.legalBodyName, 'Koninklijk Museum voor Schone Kunsten Antwerpen')
    end

    lido_basenameset(
        administrativeMetadata.recordWrap.recordSource.legalBodyName,
        or_record.department.db.department
    )

    # Create legalBodyWeblink

    add_field(or_record.legalBodyWeblink, 'http://kmska.be')

    # Add the created legalBodyWeblink to LIDO recordSource as LIDO legalBodyWeblink

    lido_basevalue(
        administrativeMetadata.recordWrap.recordSource.legalBodyWeblink,
        or_record.legalBodyWeblink
    )


## LIDO resourceWrap

# LIDO resourceID & linkResource

    # Add representationpid from TMS (if present) to LIDO resourceSet as LIDO resourceID and as LIDO linkResource

    if all_match(or_record.object_number.pid.representationPid, '.*\S.*')

        copy_field(or_record.object_number.pid.representationPid, administrativeMetadata.resourceWrap.resourceSet.resourceID._)
        add_field(administrativeMetadata.resourceWrap.resourceSet.resourceID.type, "purl")
        add_field(administrativeMetadata.resourceWrap.resourceSet.resourceID.label, "representationPID")

        copy_field(or_record.object_number.pid.representationPid, administrativeMetadata.resourceWrap.resourceSet.resourceRepresentation.linkResource._)

    end



### Add lang attributes to descriptiveMetadata and administrativeMetadata

    add_field(descriptiveMetadata.lang, 'nl')
    add_field(administrativeMetadata.lang, 'nl')



### Add empty values for required LIDO elements/attributes if not already exist

    unless exists(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType)
        add_field(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.term._, "")
    end



### Remove the 'or_record' structure

    remove_field(or_record)
