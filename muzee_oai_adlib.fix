# Catmandu Fix
#
# Institution: Mu.ZEE Ostend
# Description: Converts Adlib Structured XML exposed via ErfgoedInzicht OAI to LIDO 1.0
# Created: 9/4/2020



### Prepare an intermediate structure

# Copy relevant Adlib fields in order to create a dedicated lido structure

    copy_field(_metadata.Digital_reference, or_record.pids)
    copy_field(_metadata.Alternative_number, or_record.workPid)
    copy_field(_metadata.Object_name, or_record.object_name)
    copy_field(_metadata.object_category, or_record.object_category)
    copy_field('_metadata.object_category\.lref', or_record.object_category_id)
    copy_field(_metadata.Title, or_record.title)
    copy_field(_metadata.Titel_translation, or_record.title_translation)
    copy_field('_metadata.institution\.name', or_record.institution)
    copy_field(_metadata.object_number, or_record.object_number)
#    copy_field(_metadata.print_state, or_record.print_state)
#    copy_field(_metadata.copy_number, or_record.copy_number)
#    copy_field(_metadata.edition, or_record.edition)
    copy_field(_metadata.Description, or_record.description)
#    copy_field(_metadata.part, or_record.part)
#    copy_field(_metadata.number_of_parts, or_record.number_of_parts)
    copy_field(_metadata.Dimension, or_record.dimensions)
    copy_field('_metadata.dimension\.free', or_record.displaydimension)
#    copy_field(_metadata.Inscription, or_record.inscription)
#    copy_field(_metadata.Current_location, or_record.current_location)
#    copy_field(_metadata.Acquisition_source, or_record.acquisition_source)
#    copy_field('_metadata.acquisition\.date', or_record.acquisition_date)
#    copy_field('_metadata.acquisition\.method', or_record.acquisition_method)
#    copy_field('_metadata.acquisition\.method\.lref', or_record.acquisition_method_id)
#    copy_field(_metadata.credit_line, or_record.acquisition_creditline)
#    copy_field(_metadata.Exhibition, or_record.exhibition)
    copy_field(_metadata.Production, or_record.production)
    copy_field(_metadata.Production_date, or_record.production_date)
    copy_field('_metadata.production\.period', or_record.production_period)
    copy_field('_metadata.production\.period\.lref', or_record.production_period_id)
    copy_field(_metadata.Material, or_record.materials)
    copy_field(_metadata.material_description, or_record.physical_description)
#    copy_field(_metadata.Technique, or_record.technique)
#    copy_field(_metadata.current_owner, or_record.current_owner)
    copy_field('_metadata.content\.motif\.general', or_record.content_motif_general)
    copy_field('_metadata.content\.motif\.general\.lref', or_record.content_motif_general_id)
#    copy_field('_metadata.content\.motif\.specific', or_record.content_motif_specific)
#    copy_field('_metadata.content\.motif\.specific\.lref', or_record.content_motif_specific_id)
    copy_field(_metadata.Content_subject, or_record.depicted_subject)
#    copy_field(_metadata.Associated_subject, or_record.associated_subject)
    copy_field(_metadata.Content_person, or_record.depicted_person)
#    copy_field(_metadata.Associated_person, or_record.associated_person)
#    copy_field('_metadata.content\.date\.period', or_record.depicted_period)
#    copy_field(_metadata.Associated_period, or_record.associated_period)
    copy_field(_metadata.priref, or_record.priref)
#    copy_field(_metadata.Rights, or_record.rights)

    
 
# Remove all Adlib fields, retaining only the fields to create the lido structure

    retain(or_record)



### Mapping to lido structure

# Mapping Facets
# --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Adlib                                             LIDO                                                VKC                     Invulboek veld
#                                                       lido:lidoRecID
#   Digital_reference.digital_reference                     type: purl                                                              waarde databanknummer
#                                                           type: urn
#   Alternative_number                                  lido:objectPublishedID                              Work PURL               waarde objectnummer
#                                                       lido:category
#                                                       lido:objectWorkType
#                                                           lido:conceptID
#   Object_name.object_name\.lref                               pref: preferred
#                                                               pref: alternate                                                     identificatie objectnaam
#                                                           lido:term
#   Object_name.object_name                                     pref: preferred                             Subtype                 term objectnaam
#                                                               pref: alternate                             Subtype
#                                                       lido:classification
#                                                           type: object-category
#                                                               lido:conceptID
#   object_category.\lref                                           pref: preferred
#                                                                   pref: alternate                                                 identificatie
#                                                               lido:term
#   object_category                                                 pref: preferred                         Type                    term
#                                                                   pref: alternate                         Type
#                                                       lido:titleSet
#   Title                                                   pref: preferred                                                         titel
#   Titel_translation                                       pref: alternate
#                                                       lido:inscriptions
#   Inscription.inscription\.content                        lido:inscriptionTranscription
#                                                           lido:inscriptionDescription
#   Inscription.inscription\.type                               type: type
#   Inscription.inscription\.position                           type: position
#                                                       lido:repositorySet
#   institution\.name                                       lido:repositoryName                             Instelling              naam bewaarinstelling
#                                                           lido:workID
#   object_number                                               type: object-number                         Inventarisnummer        waarde objectnummer
#   Current_location.current_location                       lido:repositoryLocation
#                                                       lido:displayStateEditionWrap
#   print_state                                             lido:displayState
#                                                           lido:displayEdition
#   copy_number                                                 label: copy-number
#   edition                                                     label: edition
#                                                       lido:objectDescriptionSet
#   Description                                             no type                                         Beschrijving            korte beschrijving
#   part                                                    type: part
#   number_of_parts                                         type: number-of-parts
#                                                       lido:objectMeasurementsSet
#   dimension\.free                                         lido:displayObjectMeasurements                  Dimensies
#                                                           lido:objectMeasurements
#                                                               lido:measurementsSet
#   Dimension.dimension\.type                                       lido:measurementType                                            dimensie afmeting
#   Dimension.dimension\.unit                                       lido:measurementUnit                                            eenheid afmeting
#   Dimension.dimension\.value                                      lido:measurementValue                                           waarde afmeting
#   Dimension.dimension\.part                                   lido:extentMeasurements                                             onderdeel afmeting
#                                                       lido:eventType
#                                                           lido:term
#                                                               acquisition
#   Acquisition_source.acquisition\.source                          lido:eventActor                                                 naam verwervingsbron
#                                                                   lido:eventDate
#   acquisition\.date                                                   lido:displayDate                                            waarde verwervingdatum
#                                                                   lido:eventMethod
#                                                                       lido:conceptID
#   acquisition\.method\.lref                                               pref: preferred
#                                                                           pref: alternate                                         identifictatie verwervingsmethode
#                                                                       lido:term
#   acquisition\.method                                                     pref: preferred                                         term verwervingsmethode
#                                                                           pref: alternate
#   credit_line                                                     lido:eventDescriptionSet
#                                                       lido:eventType
#                                                           lido:term
#                                                               exhibition
#   Exhibition.exhibition                                           lido:eventName
#                                                                   lido:eventDate
#   Exhibition.exhibition\.date\.start                                  lido:earliestDate
#   Exhibition.exhibition\.date\.end                                    lido:latestDate
#                                                       lido:eventType
#                                                           lido:term
#                                                               production
#                                                                   lido:eventActor
#                                                                       lido:actorID
#   Production.creator\.lref                                                type: local
#                                                                           type: purl                                              identificatie vervaardiger
#   Production.creator                                                  lido:nameActorSet
#                                                                           pref: preferred                 Vervaardiger            naam vervaardiger
#                                                                           pref: alternate
#                                                                       lido:vitalDatesActor
#   Production.creator\.date_of_birth                                       lido:earliestDate
#   Production.creator\.date_of_death                                       lido:latestDate
#   Production.creator\.role                                            lido:roleActor                      Vervaardiger            rol vervaardiger
#   Production.creator\.qualifier                                       lido:attributionQualifierActor      Vervaardiger            kwalificatie vervaardiger
#                                                                   lido:eventDate
#                                                                       lido:displayDate                    Datering
#   Production_date.production\.date\.start                             lido:earliestDate                                           begindatum
#   Production_date.production\.date\.start\.prec                           type
#   Production_date.production\.date\.end                               lido:latestDate                                             einddatum
#   Production_date.production\.date\.end\.prec                             type
#                                                                   lido:periodName
#   production\.period\.lref                                            lido:conceptID
#   production\.period                                                  lido:term
#                                                                   lido:eventPlace
#                                                                       lido:placeID
#   Production.production\.place\.lref                                      type: local
#                                                                       lido:namePlaceSet
#   Production.production\.place                                            type: preferred
#                                                                   lido:termMaterialsTech
#                                                                       type: material
#                                                                           lido:conceptID
#   Material.material\.lref                                                     pref: preferred
#                                                                               pref: alternate                                     identificatie materiaal
#                                                                           lido:term
#   Material.material                                                           pref: preferred             Materiaal               term materiaal
#                                                                               pref: alternate
#                                                                       type: technique
#                                                                           lido:conceptID
#   Technique.technique\.lref                                                   pref: preferred
#                                                                           lido:term
#   Technique.technique                                                         pref: preferred
#   material_description                                            lido:displayMaterialsTech
#                                                       lido:eventType
#                                                           lido:term
#                                                               provenance
#   current_owner                                                   lido:eventActor
#                                                       lido:eventType
#                                                           lido:term
#                                                               check
#                                                                   lido:eventDescriptionSet                                        term conditie
#                                                                   lido:eventActor
#                                                                       lido:nameActorSet                                           assessor conditie
#                                                                   lido:eventDate
#                                                                       lido:displayDate                                            datum conditie
#                                                       lido:objectRelationWrap
#                                                           lido:subject
#                                                               type: content-motif-general
#                                                                   lido:subjectConcept
#                                                                       lido:conceptID
#   content\.motif\.general\.lref                                           pref: preferred
#                                                                           pref: alternate                                         identificatie hoofdmotief
#                                                                       lido:term
#   content\.motif\.general                                                 pref: preferred                 Onderwerp               term hoofdmotief
#                                                                           pref: alternate                 Onderwerp
#                                                               type: content-motif-specific
#                                                                   lido:subjectConcept
#                                                                       lido:conceptID
#   content\.motif\.specific\.lref                                          pref: preferred
#                                                                       lido:term
#   content\.motif\.specific                                                pref: preferred
#                                                               no type
#                                                                   lido:subjectConcept
#   Content_subject.content\.subject\.lref                              lido:conceptID                                              identificatie afgebeeld concept
#   Content_subject.content\.subject                                    lido:term                                                   term afgebeeld concept
#                                                                   lido:subjectActor
#   Content_person.content\.person\.name\.lref                          lido:actorID                                                identificatie afgebeelde persoon of instelling
#   Content_person.content\.person\.name                                lido:nameActorSet                                           naam afgebeelde persoon of instelling
#                                                                   lido:subjectDate
#   content\.date\.period                                               lido:displayDate
#                                                                   lido:subjectEvent
#   Content_subject.content\.subject\.lref                              lido:eventID                                                identificatie afgebeelde gebeurtenis
#   Content_subject.content\.subject                                    lido:eventName                                              naam afgebeelde gebeurtenis
#                                                                   lido:subjectPlace
#   Content_subject.content\.subject\.lref                              lido:placeID                                                identificatie afgebeelde locatie
#   Content_subject.content\.subject                                    lido:namePlaceSet                                           naam afgebeelde locatie
#                                                               type: associated
#                                                                   lido:subjectConcept
#   Associated_subject.association\.subject                             lido:term
#                                                                   lido:subjectActor
#   Associated_person.association\.person                               lido:nameActorSet
#                                                                   lido:subjectDate
#   Associated_period.association\.period                               lido:displayDate
#                                                       lido:rightsWorkWrap
#                                                           lido:rightsType
#                                                               lido:conceptID                                                      identificatie rechten werk
#                                                               lido:term                                                           term rechten werk
#   Rights.rights\.notes                                    lido:creditLine
#                                                       lido:recordWrap
#                                                           lido:recordID
#   Digital_reference.digital_reference                         type: global                                Data PURL               waarde databanknummer
#   priref                                                      type: local                                                         waarde databanknummer
#                                                           lido:recordType
#                                                               lido:conceptID
#                                                               lido:term
#                                                           lido:recordSource
#                                                               lido:legalBodyID                                                    identificatie data provider
#   institution\.name                                           lido:legalBodyName                                                  naam data provider
#                                                               lido:legalBodyWeblink
#                                                           lido:recordRights
#                                                               lido:rightsType
#                                                                   type:conceptID                                                  identificatie rechten status
#                                                                   type:term                                                       term rechten status
#                                                       lido:resourceWrap
#   Digital_reference.digital_reference                     lido:resourceID
#   Digital_reference.digital_reference                     lido:resourceRepresentation



### LIDO lidoRecID

    # ID
    #
    # The ID in Solr is based on the data_pid. The data_pid is converted to a string
    # which can be safely used as an identifier in Project Blacklight. The format of
    # the ID field looks like this:
    #
    #   oai:datahub.vlaamsekunstcollectie.be:<domain>:<identifier>
    #   ex. oai:datahub.vlaamsekunstcollectie.be:muzee.be:254
    #   ex. oai:datahub.vlaamsekunstcollectie.be:collectievlaamsegemeenschap.be:837
    #
    # Note: the .tld is stripped from the domainname because the . (dot) breaks the
    # route matching algoritm.

    unless is_array(or_record.pids) 
        move_field(or_record.pids, or_record.tmp)
        set_array(or_record.pids)
        move_field(or_record.tmp, or_record.pids.$append)
    end

    do list(path:or_record.pids, var: c)

        if all_match('c.digital_reference\.description', 'datapid')

            if all_match(c.digital_reference, '.*\S.*')

                lido_baseid(
                    lidoRecID,
                    c.digital_reference,
                    -type: purl,
                    -source: 'Mu.ZEE, Kunstmuseum aan zee',
                    -label: dataPID,
                    -pref: alternate
                )

                copy_field(c.digital_reference, or_record.oaiPid)
                parse_text(or_record.oaiPid, '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
                join_field('or_record.oaiPid', ':')
                prepend('or_record.oaiPid', 'oai:datahub.vlaamsekunstcollectie.be:')

                lido_baseid(
                    lidoRecID,
                    or_record.oaiPid,
                    -type: urn,
                    -source: 'Vlaamse Kunstcollectie - Arthub Flanders',
                    -label: dataPID,
                    -pref: preferred
                )

            end

        end

    end

 

### LIDO objectPublishedID

    unless is_array(or_record.workPid) 
        move_field(or_record.workPid, or_record.tmp)
        set_array(or_record.workPid)
        move_field(or_record.tmp, or_record.workPid.$append)
    end

    do list(path:or_record.workPid, var: c)

        if all_match('c.alternative_number\.type', 'workpid')

            if all_match(c.alternative_number, '.*\S.*')

                lido_baseid(
                    objectPublishedID,
                    c.alternative_number,
                    -type: purl,
                    -source: 'Mu.ZEE, Kunstmuseum aan zee',
                    -label: workPID
                )

            end

        end

    end



### LIDO category

    add_field(or_record.CIDOCCategoryTerm, 'Man-Made Object')
    add_field(or_record.CIDOCCategoryURI, 'http://www.cidoc-crm.org/Entity/e22-man-made-object/version-6.1')

    lido_term(
        category,
        or_record.CIDOCCategoryTerm,
        -conceptid: or_record.CIDOCCategoryURI,
        -type: purl,
        -source: cidoc-crm
    )



### LIDO descriptiveMetadata

## LIDO objectClassificationWrap

# LIDO objectWorkType

    # If it is a string, convert to an array with a single value first.

    unless is_array(or_record.object_name) 
        move_field(or_record.object_name, or_record.tmp)
        set_array(or_record.object_name)
        move_field(or_record.tmp, or_record.object_name.$append)
    end

    # We'll have multiple terms: the corresponding value in AAT (type:alternate) and the value from Adlib (type:preferred)

    do list(path: or_record.object_name, var: c)

        # Value in Adlib

        if all_match(c.object_name, '.*\S.*')

            if all_match('c.object_name\.lref', '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$append,
                    c.object_name,
                    -conceptid: 'c.object_name\.lref',
                    -type: local,
                    -source: Adlib,
                    -pref: preferred,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$append,
                    c.object_name,
                    -pref: preferred,
                    -lang: nl
                )

            end

        end

        # Corresponding value in AAT, not (yet) retrievable via API

        copy_field(c.object_name, c.object_name_aat)

        lookup_in_store(c.object_name_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        if all_match(c.object_name_aat.aatterm, '.*\S.*')

            if all_match(c.object_name_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                    c.object_name_aat.aatterm,
                    -conceptid: c.object_name_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                    c.object_name_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

# LIDO classification [type="object-category"]

    unless is_array(or_record.object_category) 
        move_field(or_record.object_category, or_record.tmp)
        set_array(or_record.object_category)
        move_field(or_record.tmp, or_record.object_category.$append)
    end

    unless is_array(or_record.object_category_id)
        move_field(or_record.object_category_id, or_record.tmp)
        set_array(or_record.object_category_id)
        move_field(or_record.tmp, or_record.object_category_id.$append)
    end

    do list (path: or_record.object_category_id, var: c)
        copy_field(c, or_record.object_category.$append.id)
    end

    assoc(or_record.object_cat, or_record.object_category.*.id, or_record.object_category.*)

    # We'll have multiple terms for the type "object-category": the corresponding value in AAT (type:alternate) and the value from Adlib (type:preferred)

    do each (path: or_record.object_cat, var: c)

        # Value in Adlib

        if all_match(c.value, '.*\S.*')

            if all_match(c.key, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$append,
                    c.value,
                    -conceptid: c.key,
                    -type: local,
                    -source: Adlib,
                    -pref: preferred,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$append,
                    c.value,
                    -pref: preferred,
                    -lang: nl
                )

            end

            add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.type, "object-category")

        end
    
        # Corresponding value in AAT, not (yet) retrievable via API

        copy_field(c.value, c.object_category_aat)

        lookup_in_store(c.object_category_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        if all_match(c.object_category_aat.aatterm, '.*\S.*')

            if all_match(c.object_category_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last,
                    c.object_category_aat.aatterm,
                    -conceptid: c.object_category_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last,
                    c.object_category_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

            add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.type, "object-category")

        end

    end


## LIDO objectIdentificationWrap

# LIDO titleSet

    unless is_array(or_record.title) 
        move_field(or_record.title, or_record.tmp)
        set_array(or_record.title)
        move_field(or_record.tmp, or_record.title.$append)
    end

    do list(path: or_record.title, var: c)

        if all_match(c.title, '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.$append,
                c.title,
                -value_pref: preferred
            )

        end

    end

    unless is_array(or_record.title_translation) 
        move_field(or_record.title_translation, or_record.tmp)
        set_array(or_record.title_translation)
        move_field(or_record.tmp, or_record.title_translation.$append)
    end

    do list(path: or_record.title_translation, var: c)

        if all_match('c.title\.translation', '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.$first,
                'c.title\.translation',
                -value_pref: alternate
            )

        end

    end

# LIDO repositoryName

    unless is_array(or_record.institution) 
        move_field(or_record.institution, or_record.tmp)
        set_array(or_record.institution)
        move_field(or_record.tmp, or_record.institution.$append)
    end

    do list(path: or_record.institution, var: c)

        if all_match(c, '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$append.repositoryName.legalBodyName,
                c
            )

        end

    end

# LIDO workID

    unless is_array(or_record.object_number)
        move_field(or_record.object_number, or_record.tmp)
        set_array(or_record.object_number)
        move_field(or_record.tmp, or_record.object_number.$append)
    end

    do list(path: or_record.object_number, var: c)

        if all_match(c, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.workID,
                c,
                -type: object-number
            )

        end

    end

# LIDO repositoryLocation

#    unless is_array(or_record.current_location) 
#        move_field(or_record.current_location, or_record.tmp)
#        set_array(or_record.current_location)
#        move_field(or_record.tmp, or_record.current_location.$append)
#    end

#    do list(path: or_record.current_location, var: c)

#        copy_field(c.current_location, c.current_location_lookup)

#        lookup_in_store(c.current_location_lookup, DBI, data_source: "dbi:SQLite:/tmp/import.CURRENT_LOCATIONS_UTF8.sqlite")

#        if all_match(c.current_location_lookup.display_name, '.*\S.*')

#            lido_basenameset(
#                descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$append.repositoryLocation.namePlaceSet,
#                c.current_location_lookup.display_name
#            )

#        end

#    end

# LIDO displayState

#    unless is_array(or_record.print_state)
#        move_field(or_record.print_state, or_record.tmp)
#        set_array(or_record.print_state)
#        move_field(or_record.tmp, or_record.print_state.$append)
#    end

#    do list(path:or_record.print_state, var: c)

#        if all_match(c, '.*\S.*')

#            lido_basevalue(
#                descriptiveMetadata.objectIdentificationWrap.displayStateEditionWrap.displayState,
#                c
#            )

#        end

#    end

# LIDO displayEdition

#    unless is_array(or_record.copy_number)
#        move_field(or_record.copy_number, or_record.tmp)
#        set_array(or_record.copy_number)
#        move_field(or_record.tmp, or_record.copy_number.$append)
#    end

#    do list(path:or_record.copy_number, var: c)

#        if all_match(c, '.*\S.*')

#            lido_basevalue(
#                descriptiveMetadata.objectIdentificationWrap.displayStateEditionWrap.displayEdition,
#                c,
#                -label: copy-number
#            )

#        end

#    end

#    unless is_array(or_record.edition)
#        move_field(or_record.edition, or_record.tmp)
#        set_array(or_record.edition)
#        move_field(or_record.tmp, or_record.edition.$append)
#    end

#    do list(path:or_record.edition, var: c)

#        if all_match(c, '.*\S.*')

#            lido_basevalue(
#                descriptiveMetadata.objectIdentificationWrap.displayStateEditionWrap.displayEdition,
#                c,
#                -label: edition
#            )

#        end

#    end

# LIDO objectDescriptionSet

    # Description

    unless is_array(or_record.description) 
        move_field(or_record.description, or_record.tmp)
        set_array(or_record.description)
        move_field(or_record.tmp, or_record.description.$append)
    end

    do list(path: or_record.description, var: c)

        if all_match(c.description, '.*\S.*')

            lido_descriptivenote(
                descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet,
                c.description
            )

        end

    end

    # Part

#    unless is_array(or_record.part)
#        move_field(or_record.part, or_record.tmp)
#        set_array(or_record.part)
#        move_field(or_record.tmp, or_record.part.$append)
#    end

#    do list(path:or_record.part, var: c)

#        if all_match(c, '.*\S.*')

#            lido_descriptivenote(
#                descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet,
#                c
#            )

#            add_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.type, "part")

#        end

#    end

    # Number of parts

#    unless is_array(or_record.number_of_parts)
#        move_field(or_record.number_of_parts, or_record.tmp)
#        set_array(or_record.number_of_parts)
#        move_field(or_record.tmp, or_record.number_of_parts.$append)
#    end

#    do list(path:or_record.number_of_parts, var: c)

#        if all_match(c, '.*\S.*')

#            lido_descriptivenote(
#                descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet,
#                c
#            )

#            add_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.type, "number-of-parts")

#        end

#    end

# LIDO objectMeasurementsWrap

    # Take the string out of displaydimension and put it in displayObjectMeasurements in LIDO
    
    unless is_array(or_record.displaydimension) 
        move_field(or_record.displaydimension, or_record.tmp)
        set_array(or_record.displaydimension)
        move_field(or_record.tmp, or_record.displaydimension.$append)
    end

    do list(path:or_record.displaydimension, var:c)

        if all_match('c', '.*\S.*')

            add_field(descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$append)

            copy_field('c', descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.displayObjectMeasurements._)

        end

    end

    # Generate height, width, depth using the dimensions type, unit, and part params

    unless is_array(or_record.dimensions)
        move_field(or_record.dimensions, or_record.tmp)
        set_array(or_record.dimensions)
        move_field(or_record.tmp, or_record.dimensions.$append)
    end

    do list(path:or_record.dimensions, var:c)
        
        add_field(descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$append)

        if all_match('c.dimension\.type', '.*\S.*')

            copy_field('c.dimension\.type', descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementType._)

        end

        if all_match('c.dimension\.unit', '.*\S.*')

            copy_field('c.dimension\.unit', descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementUnit._)

        end

        if all_match('c.dimension\.value', '.*\S.*')

            copy_field('c.dimension\.value', descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementValue._)

        end

        if all_match('c.dimension\.part', '.*\S.*')

            copy_field('c.dimension\.part', descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.extentMeasurements._)

        end

    end

# LIDO inscriptions

#    unless is_array(or_record.inscription) 
#        move_field(or_record.inscription, or_record.tmp)
#        set_array(or_record.inscription)
#        move_field(or_record.tmp, or_record.inscription.$append)
#    end

#    do list(path:or_record.inscription, var:c)

#        if all_match('c.inscription\.content', '.*\S.*')
        
#            add_field(descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$append)

#        else

#            if all_match('c.inscription\.type', '.*\S.*')

#                add_field(descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$append)

#            else

#                if all_match('c.inscription\.position', '.*\S.*')

#                    add_field(descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$append)

#                end

#            end

#        end


#        if all_match('c.inscription\.content', '.*\S.*')

#            copy_field('c.inscription\.content', descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionTranscription._)

#        end

#        if all_match('c.inscription\.type', '.*\S.*')

#            copy_field('c.inscription\.type', descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$append.descriptiveNoteValue._)

#            add_field(descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$last.type, "type")

#        end

#        if all_match('c.inscription\.position', '.*\S.*')

#            copy_field('c.inscription\.position', descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$append.descriptiveNoteValue._)

#            add_field(descriptiveMetadata.objectIdentificationWrap.inscriptionsWrap.inscriptions.$last.inscriptionDescription.$last.type, "position")

#        end

#    end


## LIDO eventWrap

# LIDO eventType [eventType/term="acquisition"]

#    add_field(or_record.event_type, "acquisition")

#    lido_term(
#        descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
#        or_record.event_type
#    )

# LIDO eventActor [eventType/term="acquisition"]

#    unless is_array(or_record.acquisition_source) 
#        move_field(or_record.acquisition_source, or_record.tmp)
#        set_array(or_record.acquisition_source)
#        move_field(or_record.tmp, or_record.acquisition_source.$append)
#    end

#    do list (path:or_record.acquisition_source, var:c)

#        if all_match('c.acquisition\.source', '.*\S.*')

#            lido_basenameset(
#                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append.actorInRole.actor.nameActorSet,
#                'c.acquisition\.source'
#            )

#        end

#    end

# LIDO displayDate [eventType/term="acquisition"]

#    unless is_array(or_record.acquisition_date)
#        move_field(or_record.acquisition_date, or_record.tmp)
#        set_array(or_record.acquisition_date)
#        move_field(or_record.tmp, or_record.acquisition_date.$append)
#    end

#    do list (path:or_record.acquisition_date, var:c)

#        if all_match(c, '.*\S.*')

#            lido_basevalue(
#                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.displayDate,
#                c
#            )

#        end

#    end

# LIDO eventMethod [eventType/term="acquisition"]

#    unless is_array(or_record.acquisition_method)
#        move_field(or_record.acquisition_method, or_record.tmp)
#        set_array(or_record.acquisition_method)
#        move_field(or_record.tmp, or_record.acquisition_method.$append)
#    end

#    unless is_array(or_record.acquisition_method_id)
#        move_field(or_record.acquisition_method_id, or_record.tmp)
#        set_array(or_record.acquisition_method_id)
#        move_field(or_record.tmp, or_record.acquisition_method_id.$append)
#    end

#    do list (path: or_record.acquisition_method_id, var: c)
#        copy_field(c, or_record.acquisition_method.$append.id)
#    end

#    assoc(or_record.acquisition_m, or_record.acquisition_method.*.id, or_record.acquisition_method.*)

    # We'll have multiple terms: the corresponding value in AAT (type:alternate) and the value from Adlib (type:preferred)

#    do each (path:or_record.acquisition_m, var:c)

        # Value in Adlib

#        if all_match(c.value, '.*\S.*')

#            if all_match(c.key, '.*\S.*')

#                lido_term(
#                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMethod.$append,
#                    c.value,
#                    -conceptid: c.key,
#                    -type: local,
#                    -source: Adlib,
#                    -pref: preferred,
#                    -lang: nl
#                )

#            else

#                lido_term(
#                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMethod.$append,
#                    c.value,
#                    -pref: preferred,
#                    -lang: nl
#                )

#            end

#        end

        # Corresponding value in AAT, not (yet) retrievable via API

#        copy_field(c.value, c.acquisition_aat)

#        lookup_in_store(c.acquisition_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

#        if all_match(c.acquisition_aat.aatterm, '.*\S.*')

#            if all_match(c.acquisition_aat.aaturi, '.*\S.*')

#                lido_term(
#                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMethod.$last,
#                    c.acquisition_aat.aatterm,
#                    -conceptid: c.acquisition_aat.aaturi,
#                    -type: purl,
#                    -source: AAT,
#                    -pref: alternate,
#                    -lang: nl
#                )

#            else

#                lido_term(
#                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMethod.$last,
#                    c.acquisition_aat.aatterm,
#                    -pref: alternate,
#                    -lang: nl
#                )

#            end

#        end

#    end

# LIDO eventDescriptionSet [eventType/term="acquisition"]

#    unless is_array(or_record.acquisition_creditline)
#        move_field(or_record.acquisition_creditline, or_record.tmp)
#        set_array(or_record.acquisition_creditline)
#        move_field(or_record.tmp, or_record.acquisition_creditline.$append)
#    end

#    do list (path:or_record.acquisition_creditline, var:c)

#        if all_match(c, '.*\S.*')

#            lido_descriptivenote(
#                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDescriptionSet,
#                c
#            )

#        end

#    end

# LIDO eventName / date [eventType/term="exhibition"]

#    add_field(or_record.event_type, "exhibition")

#    unless is_array(or_record.exhibition)
#        move_field(or_record.exhibition, or_record.tmp)
#        set_array(or_record.exhibition)
#        move_field(or_record.tmp, or_record.exhibition.$append)
#    end

#    do list (path:or_record.exhibition, var:c)

#        lido_term(
#            descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
#            or_record.event_type
#        )

#        if all_match(c.exhibition, '.*\S.*')

#            lido_basenameset(
#                descriptiveMetadata.eventWrap.eventSet.$last.event.eventName,
#                c.exhibition
#            )

#        end

#        if all_match('c.exhibition\.date\.start', '.*\S.*')

#            if all_match('c.exhibition\.date\.end', '.*\S.*')

#                lido_date(
#                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
#                    -earliest_date: 'c.exhibition\.date\.start',
#                    -latest_date: 'c.exhibition\.date\.end'
#                )
            
#            else

#                lido_date(
#                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
#                    -earliest_date: 'c.exhibition\.date\.start'
#                )

#            end

#        else

#            if all_match('c.exhibition\.date\.end', '.*\S.*')

#                lido_date(
#                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
#                    -latest_date: 'c.exhibition\.date\.end'
#                )

#            end

#        end

#    end

# LIDO eventType [eventType/term="production"]

    add_field(or_record.event_type, "production")
    
    lido_term(
        descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
        or_record.event_type
    )

# LIDO eventActor [eventType/term="production"]

    unless is_array(or_record.production) 
        move_field(or_record.production, or_record.tmp)
        set_array(or_record.production)
        move_field(or_record.tmp, or_record.production.$append)
    end

    do list (path: or_record.production, var: c)

        trim('c.creator\.qualifier')

        if all_match(c.creator, '.*\S.*')

            lido_actor(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append,
                'c.creator\.lref',
                c.creator,
                -id_source: Adlib,
                -id_type: local,
                -name_pref: preferred
            )

            if all_match('c.creator\.date_of_birth', '.*\S.*')
                copy_field('c.creator\.date_of_birth', descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.vitalDatesActor.earliestDate._)
            end

            if all_match('c.creator\.date_of_death', '.*\S.*')
                copy_field('c.creator\.date_of_death', descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.vitalDatesActor.latestDate._)
            end

            if all_match('c.creator\.qualifier', '.*\S.*')
                copy_field('c.creator\.qualifier', descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.attributionQualifierActor._)
            end

        end

        # Role. Work around. -role switch in lido_actor does not work correctly.

        if all_match('c.creator\.role', '.*\S.*')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.roleActor,
                'c.creator\.role',
            )

        end

        # Add Persistent URI data to actor

        copy_field(c.creator, c.creator_pid)

        downcase(c.creator_pid)

        lookup_in_store(c.creator_pid, DBI, data_source: "dbi:SQLite:/tmp/import.CREATORS_UTF8.sqlite")

        # Preferred label from Flemish Art Collection concordance database

        if all_match(c.creator_pid._id, '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.nameActorSet.$last,
                c.creator_pid.display_name,
                -value_pref: alternate
            )

        end

        # Creator Persistent URI's

        if all_match(c.creator_pid.viaf_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator_pid.viaf_uri,
                -source: VIAF,
                -type: purl
            )

        end

        if all_match(c.creator_pid.rkd_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator_pid.rkd_uri,
                -source: RKD,
                -type: purl
            )

        end

        if all_match(c.creator_pid.wikidata_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator_pid.wikidata_uri,
                -source: Wikidata,
                -type: purl
            )

        end

    end

# LIDO displayDate [eventType/term="production"]

    unless is_array(or_record.production_date) 
        move_field(or_record.production_date, or_record.tmp)
        set_array(or_record.production_date)
        move_field(or_record.tmp, or_record.production_date.$append)
    end

    do list(path:or_record.production_date, var:d)

        if all_match('d.production\.date\.start', '.*\S.*')

            if all_match('d.production\.date\.end', '.*\S.*')

                if in('d.production\.date\.start', 'd.production\.date\.end')

                    copy_field('d.production\.date\.start', or_record.displayDate)

                else

                    if all_match('d.production\.date\.end\.prec', '.*\S.*')

                        paste(or_record.date_end, 'd.production\.date\.end\.prec', 'd.production\.date\.end')

                        paste(or_record.displayDate, 'd.production\.date\.start', or_record.date_end, join_char:' - ')

                    else

                        paste(or_record.displayDate, 'd.production\.date\.start', 'd.production\.date\.end', join_char:' - ')

                    end

                end

            else

                copy_field('d.production\.date\.start', or_record.displayDate)

            end

            if all_match('d.production\.date\.start\.prec', '.*\S.*')

                paste(or_record.displayDate, 'd.production\.date\.start\.prec', or_record.displayDate)

            end

        else

            if all_match('d.production\.date\.end', '.*\S.*')

                copy_field('d.production\.date\.end', or_record.displayDate)

                if all_match('d.production\.date\.end\.prec', '.*\S.*')

                    paste(or_record.displayDate, 'd.production\.date\.end\.prec', or_record.displayDate)

                end

            else

                add_field(or_record.displayDate, "incorrect date format")

            end

        end

        unless all_match(or_record.displayDate, "incorrect date format")

            lido_basevalue(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.displayDate,
                or_record.displayDate
            )

        end

    end

# LIDO date [eventType/term="production"]

    set_array(or_record.earliest_dates)
    set_array(or_record.latest_dates)

    do list(path:or_record.production_date, var:d)

        if all_match('d.production\.date\.start', '.*\S.*')

            prepend('d.production\.date\.start', '#date#')

            if all_match('d.production\.date\.start\.prec', '.*\S.*')

                prepend('d.production\.date\.start\.prec', '#prec#')
                paste('d.production\.date\.start','d.production\.date\.start','d.production\.date\.start\.prec',join_char:"")

            end

            move_field('d.production\.date\.start', or_record.earliest_dates.$append)

        end

        if all_match('d.production\.date\.end', '.*\S.*')

            prepend('d.production\.date\.end', '#date#')

            if all_match('d.production\.date\.end\.prec', '.*\S.*')

                prepend('d.production\.date\.end\.prec', '#prec#')
                paste('d.production\.date\.end','d.production\.date\.end','d.production\.date\.end\.prec',join_char:"")

            end

            move_field('d.production\.date\.end', or_record.latest_dates.$append)

        end

    end

    if all_match(or_record.earliest_dates.0, '.*\S.*')

        sort_field(or_record.earliest_dates)
        if any_match(or_record.earliest_dates.0, '#date#(.*)#prec#(.*)')
            parse_text(or_record.earliest_dates.0, '#date#(.*)#prec#(.*)')
        else
            if any_match(or_record.earliest_dates.0, '#date#(.*)')
                parse_text(or_record.earliest_dates.0, '#date#(.*)')
            end
        end

    end

    if all_match(or_record.latest_dates.0, '.*\S.*')

        sort_field(or_record.latest_dates, reverse:1)
        if any_match(or_record.latest_dates.0, '#date#(.*)#prec#(.*)')
            parse_text(or_record.latest_dates.0, '#date#(.*)#prec#(.*)')
        else
            if any_match(or_record.latest_dates.0, '#date#(.*)')
                parse_text(or_record.latest_dates.0, '#date#(.*)')
            end
        end

    end

    if all_match(or_record.earliest_dates.0.0, '.*\S.*')

        if all_match(or_record.earliest_dates.0.1, '.*\S.*')

            if all_match(or_record.latest_dates.0.0, '.*\S.*')

                if all_match(or_record.latest_dates.0.1, '.*\S.*')

                    lido_date(
                        descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                        -earliest_date: or_record.earliest_dates.0.0,
                        -earliest_date_type: or_record.earliest_dates.0.1,
                        -latest_date: or_record.latest_dates.0.0,
                        -latest_date_type: or_record.latest_dates.0.1
                    )

                else

                    lido_date(
                        descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                        -earliest_date: or_record.earliest_dates.0.0,
                        -earliest_date_type: or_record.earliest_dates.0.1,
                        -latest_date: or_record.latest_dates.0.0
                    )

                end

            else

                lido_date(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                    -earliest_date: or_record.earliest_dates.0.0,
                    -earliest_date_type: or_record.earliest_dates.0.1
                )

            end

        else

            if all_match(or_record.latest_dates.0.0, '.*\S.*')

                if all_match(or_record.latest_dates.0.1, '.*\S.*')

                    lido_date(
                        descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                        -earliest_date: or_record.earliest_dates.0.0,
                        -latest_date: or_record.latest_dates.0.0,
                        -latest_date_type: or_record.latest_dates.0.1
                    )

                else

                    lido_date(
                        descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                        -earliest_date: or_record.earliest_dates.0.0,
                        -latest_date: or_record.latest_dates.0.0
                    )

                end

            else

                lido_date(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                    -earliest_date: or_record.earliest_dates.0.0,
                )

            end

        end

    else

        if all_match(or_record.latest_dates.0.0, '.*\S.*')

            if all_match(or_record.latest_dates.0.1, '.*\S.*')

                lido_date(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                    -latest_date: or_record.latest_dates.0.0,
                    -latest_date_type: or_record.latest_dates.0.1
                )

            else

                lido_date(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                    -latest_date: or_record.latest_dates.0.0
                )

            end

        else

            if all_match('d.production\.date\.start\.prec', '.*\S.*')

                copy_field('d.production\.date\.start\.prec', descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date.earliestDate.type)

            end

            if all_match('d.production\.date\.end\.prec', '.*\S.*')

                copy_field('d.production\.date\.end\.prec', descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date.latestDate.type)

            end

        end

    end

# LIDO periodName [eventType/term="production"]

    unless is_array(or_record.production_period) 
        move_field(or_record.production_period, or_record.tmp)
        set_array(or_record.production_period)
        move_field(or_record.tmp, or_record.production_period.$append)
    end

    unless is_array(or_record.production_period_id) 
        move_field(or_record.production_period_id, or_record.tmp)
        set_array(or_record.production_period_id)
        move_field(or_record.tmp, or_record.production_period_id.$append)
    end

    do list (path: or_record.production_period_id, var: c)
        copy_field(c, or_record.production_period.$append.id)
    end

    assoc(or_record.period, or_record.production_period.*.id, or_record.production_period.*)

    do each (path: or_record.period, var: c)

        if all_match(c.value, '.*\S.*')

            if all_match(c.key, '.*\S.*')

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$append,
                    c.value,
                    -conceptid: c.key,
                    -lang: nl,
                    -source: Adlib,
                    -type: local
                )

            else

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$append,
                    c.value,
                    -lang: nl
                )

            end

        end

    end

# LIDO namePlaceSet [eventType/term="production"]

    unless is_array(or_record.production)
        move_field(or_record.production, or_record.tmp)
        set_array(or_record.production)
        move_field(or_record.tmp, or_record.production.$append)
    end

    do list (path: or_record.production, var: c)

        if all_match('c.production\.place', '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventPlace.$append.place.namePlaceSet,
                'c.production\.place',
                -value_pref: preferred,
                -value_lang: nl
            )

        end

        if all_match('c.production\.place\.lref', '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventPlace.$last.place.placeID,
                'c.production\.place\.lref',
                -type: local,
                -source: Adlib
            )

        end

    end

# LIDO termMaterialsTech [eventType/term="production"]

    # Materials

    unless is_array(or_record.materials) 
        move_field(or_record.materials, or_record.tmp)
        set_array(or_record.materials)
        move_field(or_record.tmp, or_record.materials.$append)
    end

    # We'll have multiple terms: the corresponding value in AAT (type:alternate) and the value from the Adlib field object_name itself (type:preferred)

    do list(path: or_record.materials, var: c)

        # Value in Adlib

        if all_match(c.material, '.*\S.*')

            add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$append.type, "material")

            if all_match('c.material\.lref', '.*\S.*')

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    c.material,
                    -conceptid: 'c.material\.lref',
                    -type: local,
                    -source: Adlib,
                    -pref: preferred,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    c.material,
                    -pref: preferred,
                    -lang: nl
                )

            end

        end

        # Corresponding value in AAT, not (yet) retrievable via API

        copy_field(c.material, c.material_aat)

        lookup_in_store(c.material_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        if all_match(c.material_aat._id, '.*\S.*')

            if all_match(c.material_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    c.material_aat.aatterm,
                    -conceptid: c.material_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    c.material_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

    # Techniques

#    unless is_array(or_record.technique)
#        move_field(or_record.technique, or_record.tmp)
#        set_array(or_record.technique)
#        move_field(or_record.tmp, or_record.technique.$append)
#    end

#    do list(path:or_record.technique, var: c)

#        if all_match(c.technique, '.*\S.*')

#            add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$append.type, "technique")

#            if all_match('c.technique\.lref', '.*\S.*')

#                lido_term(
#                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
#                    c.technique,
#                    -conceptid: 'c.technique\.lref',
#                    -type: local,
#                    -source: Adlib,
#                    -pref: preferred,
#                    -lang: nl
#                )

#            else

#                lido_term(
#                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
#                    c.technique,
#                    -pref: preferred,
#                    -lang: nl
#                )

#            end

#        end

#    end

# LIDO displayMaterialsTech [eventType/term="production"]

    unless is_array(or_record.physical_description)
        move_field(or_record.physical_description, or_record.tmp)
        set_array(or_record.physical_description)
        move_field(or_record.tmp, or_record.physical_description.$append)
    end
    
    do list(path: or_record.physical_description, var: c)

        if all_match(c, '.*\S.*')

            lido_basevalue(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.displayMaterialsTech,
                c
            )

        end

    end

# LIDO eventType [eventType/term="provenance"]

#    add_field(or_record.event_type, provenance)

#    lido_term(
#        descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
#        or_record.event_type
#    )

# LIDO eventActor [eventType/term="provenance"]

#    unless is_array(or_record.current_owner) 
#        move_field(or_record.current_owner, or_record.tmp)
#        set_array(or_record.current_owner)
#        move_field(or_record.tmp, or_record.current_owner.$append)
#    end

#    do list (path: or_record.current_owner, var: c)

#        if all_match(c, '.*\S.*')

#            lido_basenameset(
#                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append.actorInRole.actor.nameActorSet,
#                c
#            )

#        end

#    end


## LIDO objectRelationWrap

# LIDO subjectConcept / subjectEvent / subjectPlace

    # Content motif general

    unless is_array(or_record.content_motif_general)
        move_field(or_record.content_motif_general, or_record.tmp)
        set_array(or_record.content_motif_general)
        move_field(or_record.tmp, or_record.content_motif_general.$append)
    end

    unless is_array(or_record.content_motif_general_id)
        move_field(or_record.content_motif_general_id, or_record.tmp)
        set_array(or_record.content_motif_general_id)
        move_field(or_record.tmp, or_record.content_motif_general_id.$append)
    end

    do list(path:or_record.content_motif_general_id, var:c)
        copy_field(c, or_record.content_motif_general.$append.id)
    end

    assoc(or_record.general_motif, or_record.content_motif_general.*.id, or_record.content_motif_general.*)

    # We'll have multiple terms for the type "content-motif-general": the corresponding value in AAT (type:alternate) and the value from Adlib (type:preferred)

    do each(path:or_record.general_motif, var:c)

        # Value in Adlib

        if all_match(c.value, '.*\S.*')

            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.type, "content-motif-general")

            if all_match(c.key, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$append,
                    c.value,
                    -conceptid: c.key,
                    -type: local,
                    -source: Adlib,
                    -pref: preferred,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$append,
                    c.value,
                    -pref: preferred,
                    -lang: nl
                )

            end

        end

        # Corresponding value in AAT, not (yet) retrievable via API

        copy_field(c.value, c.general_motif_aat)

        lookup_in_store(c.general_motif_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        if all_match(c.general_motif_aat.aatterm, '.*\S.*')

            if all_match(c.general_motif_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                    c.general_motif_aat.aatterm,
                    -conceptid: c.general_motif_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                    c.general_motif_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

    # Content motif specific

#    unless is_array(or_record.content_motif_specific)
#        move_field(or_record.content_motif_specific, or_record.tmp)
#        set_array(or_record.content_motif_specific)
#        move_field(or_record.tmp, or_record.content_motif_specific.$append)
#    end

#    unless is_array(or_record.content_motif_specific_id)
#        move_field(or_record.content_motif_specific_id, or_record.tmp)
#        set_array(or_record.content_motif_specific_id)
#        move_field(or_record.tmp, or_record.content_motif_specific_id.$append)
#    end

#    do list(path:or_record.content_motif_specific_id, var:c)
#        copy_field(c, or_record.content_motif_specific.$append.id)
#    end

#    assoc(or_record.specific_motif, or_record.content_motif_specific.*.id, or_record.content_motif_specific.*)

#    do each(path:or_record.specific_motif, var:c)

#        if all_match(c.value, '.*\S.*')

#            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.type, "content-motif-specific")

#            if all_match(c.key, '.*\S.*')

#                lido_term(
#                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$append,
#                    c.value,
#                    -conceptid: c.key,
#                    -type: local,
#                    -source: Adlib,
#                    -pref: preferred,
#                    -lang: nl
#                )

#            else

#                lido_term(
#                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$append,
#                    c.value,
#                    -pref: preferred,
#                    -lang: nl
#                )

#            end

#        end

#    end

    # Depicted subject

    unless is_array(or_record.depicted_subject) 
        move_field(or_record.depicted_subject, or_record.tmp)
        set_array(or_record.depicted_subject)
        move_field(or_record.tmp, or_record.depicted_subject.$append)
    end

    do list(path:or_record.depicted_subject, var:c)

        if all_match('c.content\.subject', '.*\S.*')

            if all_match('c.content\.subject\.type.value.2.content', 'geografie')

                lido_basenameset(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.subjectPlace.$append.place.namePlaceSet,
                    'c.content\.subject'
                )

                if all_match('c.content\.subject\.lref', '.*\S.*')

                    lido_baseid(
                        descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectPlace.$last.place.placeID,
                        'c.content\.subject\.lref',
                        -source: Adlib,
                        -type: local
                    )

                end

            else

                if all_match('c.content\.subject\.type.value.2.content', 'gebeurtenis')

                    set_field(or_record.event_type, event)
                    set_field(or_record.event_type_URI, 'http://www.cidoc-crm.org/Entity/e5-event/version-6.2')

                    lido_term(
                        descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.subjectEvent.$append.event.eventType,
                        or_record.event_type,
                        -conceptid: or_record.event_type_URI,
                        -type: purl,
                        -source: cidoc-crm
                    )

                    lido_basenameset(
                        descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectEvent.$last.event.eventName,
                        'c.content\.subject'
                    )

                    if all_match('c.content\.subject\.lref', '.*\S.*')

                        lido_baseid(
                            descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectEvent.$last.event.eventID,
                            'c.content\.subject\.lref',
                            -source: Adlib,
                            -type: local
                        )

                    end

                else

                    if all_match('c.content\.subject\.type.value.2.content', 'activiteit')

                        set_field(or_record.event_type, activity)
                        set_field(or_record.event_type_URI, 'http://www.cidoc-crm.org/Entity/e7-activity/version-6.2')

                        lido_term(
                            descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.subjectEvent.$append.event.eventType,
                            or_record.event_type,
                            -conceptid: or_record.event_type_URI,
                            -type: purl,
                            -source: cidoc-crm
                        )

                        lido_basenameset(
                            descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectEvent.$last.event.eventName,
                            'c.content\.subject'
                        )

                        if all_match('c.content\.subject\.lref', '.*\S.*')

                            lido_baseid(
                                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectEvent.$last.event.eventID,
                                'c.content\.subject\.lref',
                                -source: Adlib,
                                -type: local
                            )

                        end

                    else

                        if all_match('c.content\.subject\.lref', '.*\S.*')

                            lido_term(
                                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.subjectConcept.$append,
                                'c.content\.subject',
                                -conceptid: 'c.content\.subject\.lref',
                                -type: local,
                                -source: Adlib
                            )

                        else

                            lido_term(
                                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.subjectConcept.$append,
                                'c.content\.subject'
                            )

                        end

                    end

                end

            end

        end

    end

    # Associated subject

#    unless is_array(or_record.associated_subject)
#        move_field(or_record.associated_subject, or_record.tmp)
#        set_array(or_record.associated_subject)
#        move_field(or_record.tmp, or_record.associated_subject.$append)
#    end

#    do list(path:or_record.associated_subject, var:c)

#        if all_match('c.association\.subject', '.*\S.*')

#            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.type, "associated")

#            lido_term(
#                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$append,
#                'c.association\.subject'
#            )

#        end

#    end

# LIDO subjectActor

    # Depicted person

    unless is_array(or_record.depicted_person) 
        move_field(or_record.depicted_person, or_record.tmp)
        set_array(or_record.depicted_person)
        move_field(or_record.tmp, or_record.depicted_person.$append)
    end

    do list(path:or_record.depicted_person, var:c)

        if all_match('c.content\.person\.name', '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.subjectActor.$append.actor.nameActorSet,
                'c.content\.person\.name'
            )

            if all_match('c.content\.person\.name\.lref', '.*\S.*')

                lido_baseid(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectActor.$last.actor.actorID,
                    'c.content\.person\.name\.lref',
                    -type: local,
                    -source: Adlib
                )

            end

        end

    end

    # Associated person

#    unless is_array(or_record.associated_person)
#        move_field(or_record.associated_person, or_record.tmp)
#        set_array(or_record.associated_person)
#        move_field(or_record.tmp, or_record.associated_person.$append)
#    end

#    do list(path:or_record.associated_person, var:c)

#        if all_match('c.association\.person', '.*\S.*')

#            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.type, "associated")

#            lido_basenameset(
#                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectActor.actor.nameActorSet,
#                'c.association\.person'
#            )

#        end

#    end

# LIDO subjectDate

    # Depicted period

#    unless is_array(or_record.depicted_period)
#        move_field(or_record.depicted_period, or_record.tmp)
#        set_array(or_record.depicted_period)
#        move_field(or_record.tmp, or_record.depicted_period.$append)
#    end

#    do list(path:or_record.depicted_period, var:c)

#        if all_match(c, '.*\S.*')

#            lido_basevalue(
#                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.subjectDate.displayDate,
#                c
#            )

#        end

#    end

    # Associated period

#    unless is_array(or_record.associated_period)
#        move_field(or_record.associated_period, or_record.tmp)
#        set_array(or_record.associated_period)
#        move_field(or_record.tmp, or_record.associated_period.$append)
#    end

#    do list(path:or_record.associated_period, var:c)

#        if all_match('c.association\.period', '.*\S.*')

#            add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.type, "associated")

#            lido_basevalue(
#                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectDate.displayDate,
#                'c.association\.period'
#            )

#        end

#    end



### LIDO administrativeMetadata

## LIDO rightsWorkWrap

# LIDO creditLine

#    do list(path: or_record.rights, var: c)

#        if all_match('c.rights\.notes', '.*\S.*')

#            lido_basevalue(
#                administrativeMetadata.rightsWorkWrap.rightsWorkSet.$append.creditLine,
#                'c.rights\.notes'
#            )

#        end

#    end

    do list(path: or_record.object_number, var: c)

        lookup_in_store(c, DBI, data_source: 'dbi:SQLite:/tmp/import.RIGHTS.sqlite')

        if all_match(c.rights, '.*\S.*')

            lido_basevalue(
                administrativeMetadata.rightsWorkWrap.rightsWorkSet.creditLine,
                c.rights
            )

        end

    end


## LIDO recordWrap

# LIDO recordID

    do list(path:or_record.pids, var: c)

        if all_match('c.digital_reference\.description', 'datapid')

            if all_match(c.digital_reference, '.*\S.*')

                lido_baseid(
                    administrativeMetadata.recordWrap.recordID,
                    c.digital_reference,
                    -type: global
                )

            end

        end

    end

    unless is_array(or_record.priref) 
        move_field(or_record.priref, or_record.tmp)
        set_array(or_record.priref)
        move_field(or_record.tmp, or_record.priref.$append)
    end

    do list(path:or_record.priref, var: c)

        if all_match(c,'.*\S.*')

            if exists(or_record.priref_tmp)

                unless in(or_record.priref_tmp, c)

                    lido_baseid(
                        administrativeMetadata.recordWrap.recordID,
                        c,
                        -type: local
                    )

                end

            else

                lido_baseid(
                    administrativeMetadata.recordWrap.recordID,
                    c,
                    -type: local
                )

            end

            copy_field(c, or_record.priref_tmp)

        end

    end

# LIDO recordType

    add_field('or_record.AATRecordTypeTerm', 'Item')
    add_field('or_record.AATRecordTypeID', 'http://vocab.getty.edu/aat/300133025')

    lido_term(
        administrativeMetadata.recordWrap.recordType,
        or_record.AATRecordTypeTerm,
        -conceptid: or_record.AATRecordTypeID,
        -type: local,
        -source: AAT
    )

# LIDO recordSource

    do list(path: or_record.institution, var: c)

        if all_match(c, '.*\S.*')

            lido_basenameset(
                administrativeMetadata.recordWrap.recordSource.legalBodyName,
                c
            )

        end

    end

    add_field('or_record.LegalBodyWebLink', 'http://muzee.be')

    lido_basevalue(
        administrativeMetadata.recordWrap.recordSource.legalBodyWeblink,
        or_record.LegalBodyWebLink
    )


## LIDO resourceWrap

# LIDO resourceID & linkResource

    do list(path:or_record.pids, var: c)

        if all_match('c.digital_reference\.description', 'representationpid')

            if all_match(c.digital_reference, '.*\S.*')

                copy_field(c.digital_reference, administrativeMetadata.resourceWrap.resourceSet.resourceID._)
                add_field(administrativeMetadata.resourceWrap.resourceSet.resourceID.type, "purl")
                add_field(administrativeMetadata.resourceWrap.resourceSet.resourceID.label, "representationPID")

                copy_field(c.digital_reference, administrativeMetadata.resourceWrap.resourceSet.resourceRepresentation.linkResource._)

            end

        end

    end



### Add lang attributes to descriptiveMetadata and administrativeMetadata (required LIDO attributes)

    add_field(descriptiveMetadata.lang, nl)

    add_field(administrativeMetadata.lang, nl)



### Add empty values for required LIDO elements/attributes if not already exist

    if exists(descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet)
        do list(path:descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet, var:c)
            if exists(c.objectMeasurements.measurementsSet)
                unless exists(c.objectMeasurements.measurementsSet.measurementType)
                    add_field(c.objectMeasurements.measurementsSet.measurementType, "")
                end
                unless exists(c.objectMeasurements.measurementsSet.measurementUnit)
                    add_field(c.objectMeasurements.measurementsSet.measurementUnit, "")
                end
                unless exists(c.objectMeasurements.measurementsSet.measurementValue)
                    add_field(c.objectMeasurements.measurementsSet.measurementValue, "")
                end
            end
        end
    end



### Remove the 'or_record' structure

    remove_field(or_record)
